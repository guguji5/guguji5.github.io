{"meta":{"title":"咕咕鸡的前端博客","subtitle":null,"description":null,"author":"Damon Du","url":"guguji5.github.io"},"pages":[{"title":"分类","date":"2021-07-25T07:53:39.000Z","updated":"2021-07-25T07:53:39.000Z","comments":false,"path":"categories/index.html","permalink":"guguji5.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2021-07-25T07:53:39.000Z","updated":"2021-07-25T07:53:39.000Z","comments":false,"path":"repository/index.html","permalink":"guguji5.github.io/repository/index.html","excerpt":"","text":""},{"title":"迷你糊的老干爹","date":"2018-11-09T05:31:45.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"about/index.html","permalink":"guguji5.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-25T07:53:39.000Z","updated":"2021-07-25T07:53:39.000Z","comments":false,"path":"tags/index.html","permalink":"guguji5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记录一个bug","slug":"记录一个bug","date":"2021-08-01T01:56:36.000Z","updated":"2021-08-01T02:00:05.000Z","comments":true,"path":"记录一个bug/","link":"","permalink":"guguji5.github.io/记录一个bug/","excerpt":"","text":"接口格式该字段是 string，多个id可以通过空格分割，如下图。虽然我们是ts，但是只能把类型写成string 1&#123;notify_groups: \"2 1\" &#125; 新增时，用户操作完，需要按空格 join 1transportData.notify_groups = transportData.notify_groups.join(' '); 编辑时从接口获取数据再按空格split 1notify_groups = curStrategyObj.notify_groups.length &gt; 0 ? curStrategyObj.notify_groups.split(' '): [] 但是编辑时候有问题，只展示id如下图。 why ? 因为从图一可以看，该Select是从接口获取的，id为number，而前端的组件是将展示的label和背后实际的value分开的。拿该组件距离，它展示的name字段，但是读到的数据是id字段。 12345const notifyGroupsOptions = notifyGroups.map((ng: Team) =&gt; ( &lt;Option value=&#123;ng.id&#125; key=&#123;ng.id&#125;&gt; &#123;ng.name&#125; &lt;/Option&gt; )); Bug怎么产生的呢？因为split 后的数据还是string，而该组件向外抛（或者获取）的数据是number。前端改起来很容易，map时候加个Number方法处理一下就好。 由此bug想到，如果后端把该字段设计成 number[]，前端这么多transfrom就都不必了，还可以用ts的interface来静态检查。何况本来就是user-groups的id字段组成的。","categories":[],"tags":[]},{"title":"import-html-entry源码浅析","slug":"源码浅析","date":"2021-08-01T01:52:52.000Z","updated":"2021-08-01T01:54:20.000Z","comments":true,"path":"源码浅析/","link":"","permalink":"guguji5.github.io/源码浅析/","excerpt":"","text":"难道没人好奇qiankun是如何实现html entry的吗？ single-spa和qiankun最大的不同，我认为就是qiankun实现了html entry，而single-spa只能是js entry 之前使用single-spa的过程中，发现如果有多个chunk 插入到html中，那么他们的执行顺序会很关键。而从下图single-spa注册应用的钩子函数来看，它只暴露了一个方法来加载资源，这意味着如果你有多个chunk，你需要自己根据加载顺序依次加载。简而言之，它必须串行加载，浪费时间，白屏时间长 123456789101112singleSpa.registerApplication( 'appName', () =&gt; System.import('appName'), // 加载appName 对应的js资源 location =&gt; location.pathname.startsWith('appName'),);// 它需要依次加载chunksingleSpa.registerApplication( 'appName', () =&gt; System.import('chunk').then(()=&gt; System.import('appName')), // 先加载依赖的chunk，再加载appName location =&gt; location.pathname.startsWith('appName'),); qiankun解决了这个问题，它希望我们像使用iframe一样加载一个子应用，只需要知道其html的url就能加载到主应用中。这可能是其github star数已经超过single-spa的一个重要原因。难道就没人好奇，qiankun是如何实现了html entry吗？importHTML 方法究竟做了什么？ importHTML的几个关键方法 首先importHTML的参数为需要加载的页面url，拿到后会先通过fetch方法读取页面内容，并且返回为页面html的字符串，接下来的processTpl方法比较关键，是一个核心方法。它会解析html的内容并且删除注释，获取style样式及script代码（下图 line38-82）。用的方法很明显是正则+replace，但是每一个步骤都做了很多适配，比如获取script脚本，需要区分该script是不是entry script，type是JavaScript还是module，是行内script还是外链script，是相对路径还是绝对路径，是否需要处理协议等等。很复杂！借用Joel Denning的一句话 “Kuitos did great job” processTpl的返回值也从上图可见，有template，script，style，entry。为什么要把entry单独出来？它不是一个普通的JavaScript脚本么难道？肯定是因为它需要等其他JavaScript都加载好才能执行啦，不然肯定会报错的。importHTML拿到这些返回值，并暴露出来几个方法。最常用的肯定是execScript、getExternalStyleSheets、getExternalScripts 等上图画五角星的三个关键方法。 execScript做了什么事望文生义，肯定是把processTpl返回的script exec一下呗。具体流程如下图。 execScript会先调用内部方法getExternalScript，将外部script拿到和行内script合并成一个队列按顺序执行。getExternalScript的内部就是一个promise.all 这也是我们使用qiankun后它就不必串行加载script的关键所在。getExternalScript后所有的行内script和外部script都被以text的形式获取到，接下来就是执行script了，execScript还注册了两个内部函数，schedule和exec，很显然，schedule会按照次序调度exec执行script代码，如何执行JavaScript 字符串呢？ 使用eval解决的。 getExternalStyleSheets和getExternalScripts简单很多，只需要获取到style或者JavaScript文本就好了，返回给调用importHTML的开发者，自行处理。 我们一句话总结一下 import-html-entry 为 qiankun 做了那些事，”获取html的url，解析模板并暴露出来一些可以读取css、js的方法“","categories":[],"tags":[]},{"title":"一个Special的RangePicker","slug":"一个Special的RangePicker","date":"2021-08-01T01:24:07.000Z","updated":"2021-08-01T01:49:40.000Z","comments":true,"path":"一个Special的RangePicker/","link":"","permalink":"guguji5.github.io/一个Special的RangePicker/","excerpt":"","text":"很奇妙的感觉，最近在公司做一款开源的产品。公司发着工资让我做开源。嗷，其实我们的商业模式就是开源+商业化。回到正题，为什么我对一个RangePicker耿耿于怀，各种UI组件库里不是都有DatePicker么？ 没错！但是我们需要的是一个这样的RangePicker。 这里是Datadog时间选择器的文档https://docs.datadoghq.com/dashboards/guide/custom_time_frames/ Datadoghq听说市值都300亿美金了，是一个做监控领域的商业化产品，这个好用的RangePicker起码得值1亿（小声比比）。所以我得搞一个这种时间选择器出来。 Ant design 二次开发antd已经作为npm包依赖，那么第一想法就是拿它的 DatePicker+Select 通过自己事件的控制做一个出来。事情距离成功只差一步，就是DatePicker的打开和关闭，文档上说可以通过 open 属性来控制选择器的弹出和关闭，但是因为onchange事件的设计导致使用中有一个很重的bug（https://github.com/ant-design/ant-design/issues/30525） 浪费了我很多很多的时间，吃不下睡不着，始终咽不下这口气。 弃暗投明跟周围同事交流和请教之后，发现antd依赖的react-component的代码逻辑（https://github.com/react-component/picker/blob/master/src/RangePicker.tsx#L439）就导致这个问题的出现是必然行为。想改rc组件可能性不大，只好去github上找找有没有差不多的组件。果然功夫不负有心人，发现了https://github.com/y0c/react-datepicker。最终选它的原因在于以下几点。 无依赖，antd太庞大了，不想碰 TypeScript写的虽然文档有点挫，但是通过接口还是能轻松上手 CodeSandbox 肉眼可见的match需求 可配置化程度高 虽然这个库最让我中意的还就是可以通过 show 来控制时间选择器的打开与否。再后来我发现我根本需要的不是一个RangePicker而是一个Calendar！！！但还不是一个单纯的Calendar，而是一个放在RangePicker中样子的Calendar。最终做出来的是这个样子的。","categories":[],"tags":[]},{"title":"AST搞定i18n","slug":"AST搞定i18n","date":"2021-07-31T07:47:12.000Z","updated":"2021-07-31T07:53:00.000Z","comments":true,"path":"AST搞定i18n/","link":"","permalink":"guguji5.github.io/AST搞定i18n/","excerpt":"","text":"最近的夜莺开发过程中虽然提前被告知过需要做好i18n的准备，但是开发过程很紧张，难点一个又一个，i18n就被低优考虑了，等快上线前补充这个功能的时候。已经有133 个文件，577 处需要被translation函数包裹，而且每个文件前都需要引入依赖，就变成一个纯粹的体力活。每个文件都需要如下的改动 1234567import React from 'react';+ import &#123; useTranslation &#125; from 'react-i18next';export default function About() &#123;+ const &#123; t &#125; = useTranslation();- return &lt;h2&gt;关于&lt;/h2&gt;;+ return &lt;h2&gt;t('关于')&lt;/h2&gt;;&#125; 我的第一个想法是拿nodejs脚本通过正则的手段来匹配dom中的中文，属性中的中文，模板字符串中的中文等进行对应的包裹，插入和替换。团队中的另一个小伙伴提出可以使用AST来做，我们就开始了babel的探索。 babel以及AST的介绍我就不再赘述，以下链接都讲的非常清楚和深入。 下边的链接都是精华 https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#babel-traverse https://babeljs.io/docs/en/babel-types https://astexplorer.net/ https://www.cnblogs.com/jyybeam/p/13375179.html https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/ https://lihautan.com/manipulating-ast-with-javascript/#creating-a-node 上边那么多的链（血）接（泪）告诉我们几个事实。 AST的Node类型很多，很复杂，变幻多端；但是可以对不同的类型进行精准操作很方便。 看起来用字符串处理能轻松搞定的事，AST费死老劲 AST一定要用最新的包，看最新的文档。babel-types，babel-traverse等等都是过时的包，最新的包都在@babel的目录下 举个简单的例子吧，我们写一个最简单的代码const habit = t(&quot;running&quot;);如果用AST来构造是什么样子的呢？ 1234567891011const t = require('@babel/types');const generate = require('@babel/generator').default;const Identifier = t.Identifier('habit')const callee = t.Identifier('t')const arguments =t.StringLiteral('running')const CallExpression = t.CallExpression(callee, [arguments])const VariableDeclarator = t.VariableDeclarator(Identifier, CallExpression)const variableDeclaration = t.variableDeclaration('const',[VariableDeclarator])const output = generate(variableDeclaration);console.log(output.code); // 输出 const habit = t(\"running\"); 天壤之别。所以根据 https://lihautan.com/manipulating-ast-with-javascript/#creating-a-node 的推荐，使用@babel/parse将需要的结构直接解析。 123456const babelParser = require('@babel/parser');const generate = require('@babel/generator').default;const expectNode = babelParser.parse(`const habit = t(\"running\")`).program.body[0];const output = generate(expectNode);console.log(output.code); // 输出 const habit = t(\"running\"); 回到正题，我们想要的是什么？ 插入依赖 调用useTranslation hook 包裹字符串 第一个插入依赖，使用上边提到的方法找到对应的节点插入即可。 第二个插入hook，粗暴的在所有返回JSX 函数组件顶层添加一个useTranslation 调用即可。 第三个使用t方法包裹字符串则比较麻烦，需要根据dom，属性，以及模板字符串中的分别记性处理。 普通字符串处理比较简单，直接在traverse中调用path.replaceWithSourceString(&#39;t(&quot;&#39;+node.value+&#39;&quot;)&#39;)就好。但是要处理好所有的场景需要分别对StringLiteral，JSXText，TemplateLiteral，ReturnStatement，Program等类型分别进行处理。 假设我们要处理的原文件如下： source javascript 1234567891011121314151617import React from 'react';import &#123; Input &#125; from 'antd';export default function About() &#123; const name = '咕咕鸡'; const habit = '跑步'; const description = `$&#123;name&#125; 是个boy`; return ( &lt;&gt; &lt;h2&gt;关于&lt;/h2&gt; &lt;p&gt; 我的名字： &#123;name&#125;, 我的兴趣： &#123;habit + '网球'&#125; &lt;/p&gt; &lt;p&gt;&#123;description&#125;&lt;/p&gt; &lt;Input placeholder='请输入你的年龄' /&gt; &lt;/&gt; );&#125; 完整的babel脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126let fs = require('fs');const babelParser = require('@babel/parser');const traverse = require('@babel/traverse').default;const generate = require('@babel/generator').default;const t = require('@babel/types');const core = require('@babel/core');const path = require('path');const srcPath = path.resolve('../', 'src', 'pages', 'about.tsx');const includeSpace = v =&gt; /[\\f\\r\\t\\n\\s]/.test(v);const includesChinese = v =&gt;/^[\\u4e00-\\u9fa5]+/g.test(v);const extractChinese = str =&gt; str.match(/[\\u4e00-\\u9fa5]+/g)const code = fs.readFileSync(srcPath, 'utf8');let ast = babelParser.parse(code, &#123; sourceType: 'module', // default: \"script\" plugins: ['typescript', 'jsx'], &#125;);// transform the asttraverse(ast, &#123; StringLiteral(path)&#123; const &#123; node, parent &#125; = path; if(includesChinese(node.value))&#123; // console.log('StringLiteral', node.value, parent) if(t.isJSXAttribute(parent))&#123; // &lt;Input placeholder='请输入你的年龄' /&gt; =&gt; &lt;Input placeholder=&#123;t('请输入你的年龄')&#125; /&gt; // 按说应该这么写 path.replaceWith(t.jsxExpressionContainer(t.callExpression(t.identifier('t'),[t.stringLiteral(node.value)]))) // 但是结果是 &lt;Input placeholder=&#123;t(t(\"请输入你的年龄\"))&#125; /&gt; // 明显被下边的逻辑重复处理了所以可以简单点。只处理成字符串,再经过下边逻辑时就变成我们想要的结果 path.replaceWith(t.jsxExpressionContainer(t.stringLiteral(node.value))) return &#125;else&#123; path.replaceWithSourceString('t(\"'+node.value+'\")') &#125; &#125; path.skip() &#125;, JSXText(path)&#123; const &#123; node, parent &#125; = path; const &#123; value &#125; = node; if(includesChinese(node.value))&#123; if(!includeSpace(node.value))&#123; path.replaceWith(t.jsxExpressionContainer(t.stringLiteral(node.value))) return &#125;else&#123; const newAstNode = [] let chineseArr = extractChinese(node.value) chineseArr.forEach(str =&gt;&#123; let preIndex = node.value.indexOf(str) newAstNode.push(t.jSXText(node.value.slice(0,preIndex))) newAstNode.push(t.jsxExpressionContainer(t.stringLiteral(str))) &#125;) path.replaceWithMultiple(newAstNode) return // console.log(value.length, value.replace(/[\\u4e00-\\u9fa5]+/,function(value)&#123;return `&#123;t('$&#123;value&#125;')&#125;`&#125;) ) // path.replaceWithSourceString(value.replace(/[\\u4e00-\\u9fa5]+/,function(value)&#123;return `&#123;t('$&#123;value&#125;')&#125;`&#125;)) &#125; &#125; path.skip() &#125;, // 模版字符串 TemplateLiteral: function (path) &#123; const &#123; node &#125; = path; // expressions 表达式 // quasis 表示表达式中的间隙字符串, 每个表达式中间都必须有quasis, 同时首尾也必须是quasis,其中末尾元素需要是tail = true // 其中 quasis: &#123; // value: 值, 如果为‘’,一般表示给表达式的占位符 // tail: 是否为末尾 // &#125; const &#123; expressions, quasis &#125; = node; // todo 获取所有quasis中value 不为空和数字的, 如果不为末尾,记录前面有几个'' // 生成函数, 插入expressions数组中, 修改quasis节点value为空 // 如果字符串为最后一个节点,还需要生成一个空白的节点 let hasTail = false; let enCountExpressions = 0; quasis.forEach((node, index) =&gt; &#123; const &#123; value: &#123; raw &#125;, tail, &#125; = node; if (!includesChinese(raw)) &#123; return; &#125; else &#123; let newCall = t.stringLiteral(raw); expressions.splice(index + enCountExpressions, 0, newCall); enCountExpressions++; node.value = &#123; raw: '', cooked: '', &#125;; // 每增添一个表达式都需要变化原始节点,并新增下一个字符节点 quasis.push( t.templateElement( &#123; raw: '', cooked: '', &#125;, false, ), ); &#125; &#125;); quasis[quasis.length - 1].tail = true; return &#125;, ReturnStatement(path) &#123; const &#123; node, parent, parentPath &#125; = path; const &#123; body &#125; = parent; body.unshift( babelParser.parse('const &#123; t &#125; = useTranslation()').program.body[0], ); &#125;, Program(path) &#123; const &#123; node &#125; = path; const &#123; body &#125; = node; body.unshift(babelParser.parse(\"import &#123; useTranslation &#125; from 'react-i18next'\",&#123;sourceType: 'module'&#125;).program.body[0]) &#125;&#125;);const output = generate(ast);console.log(output.code); target javascript 12345678910111213141516171819import &#123; useTranslation &#125; from 'react-i18next';import React from 'react';import &#123; Input &#125; from 'antd';export default function About() &#123; const &#123; t &#125; = useTranslation(); const name = t(\"咕咕鸡\"); const habit = t(\"跑步\"); const description = `$&#123;name&#125;$&#123;t(\" 是个boy\")&#125;`; return &lt;&gt; &lt;h2&gt;&#123;t(\"关于\")&#125;&lt;/h2&gt; &lt;p&gt; &#123;t(\"我的名字\")&#125;&#123;name&#125;, &#123;t(\"我的兴趣\")&#125;&#123;habit + t(\"网球\")&#125; &lt;/p&gt; &lt;p&gt;&#123;description&#125;&lt;/p&gt; &lt;Input placeholder=&#123;t(\"请输入你的年龄\")&#125; /&gt; &lt;/&gt;;&#125; 这次的i18n的过程中学到了很多，第一次手写一个babel的visitor方法，不断的调试中感受到尤大能把vue转成JavaScript的loader是真的不易。","categories":[],"tags":[]},{"title":"2020年微前端踩坑回顾","slug":"2020年微前端踩坑回顾","date":"2021-02-01T06:23:11.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"2020年微前端踩坑回顾/","link":"","permalink":"guguji5.github.io/2020年微前端踩坑回顾/","excerpt":"","text":"2020年已经过去，在家办公了小半年，回顾过去，Time flies。 今年听说是微前端的大年，应该每个前端都会听说过微前端的概念，就像几年前angular，vue，react流行时那样。我个人是特别的佩服single-spa的作者John Denning。大概2016-2017年的样子，Angularjs出了巨大变更的Angular，React在国外也风光无两。同样是面对新旧框架不兼容的情况，我们的方案是重构，用Angular5重构项目，同时轮流负责修改之前Angularjs1.4的bug。而John写了第一版的single-spa来解决了这个问题，在新feature上使用React，已有页面维持旧项目来逐步过渡。 今年先后试用了single-spa和qiankun来对两个项目做了重构，使用single-spa来改造Mis的过往总结在这。这篇文字注意记录一下使用qiankun遇到的问题。这里的问题必须解释一下不是qiankun的问题，而是我们项目中case by case的问题。 项目背景先介绍一下为啥要用qiankun来拆分滴滴云控制台，当时考虑我们的控制台开发体验差，热更新慢，太臃肿，无法引入新的技术栈、升级组件库，为了更好支持平台化建设项目。遂考虑微服务拆分项目。这里来盗个kuitos知乎上的图，如果想做一个长长久久公有云控制台，考虑迭代和升级越早收益越高。 愿景希望将控制台庖丁解牛，拆分成几个独立的项目。每一个可以独立部署，独立开发。自由选择和升级技术栈，UI库，热更新快速。 框架对比 框架 github stars（2020.10.29） 主应用 共享依赖 子应用可否单独开发调试 部署 entry js，css隔离 路由控制 应用间通信 工程化 官方支持 飞冰 906 必须react 无 可独立启动的子应用，可以 如飞冰的截图，子应用单独部署 html，js，简单如iframe 暂未完善 简单的路由规则 有方案 无 没有专门的群，效率差 qiankun 7.3k qiankun 无 可独立启动的子应用，可以 子应用单独部署 html，js，简单如iframe js沙箱，css shadow dom等方案 基于single-spa 没方案，但有一些建议 无 有群，效率一般 single-spa 7.6k single-spa utility-modules-styleguide-api-etc import-map-override完美解决 子应用部署，需更新import-map 需要systemjs，有一定成本 官方未提供建议 精准的路由控制 有方案 有 slack，效率一般。有热心John 大概对比下来，single-spa和qiankun各有千秋。但是single-spa要求的是子项目单文件入口，如果html中插入了多个chunk，single-spa无法保证其按顺序加载，对我们的项目冲击较大，而qiankun是根据html解析，将其css script链接进行加载，无需改动，最后选择了qiankun，趟一趟水。 实践因为这次重构和其他需求是并行的，将任务拆解为以下几项 涉及到梳理业务模块及依赖关系，根据依赖关系抽取公共模块。 将必要模块放在root应用中，如登录，权限，导航等等。 如何几个子项目如何构建，部署，上线 项目结束后如何跟旧项目的feature 解决冲突 抽取公共模块后，原项目的引用路径会变化，如何使用脚本来做这件事。 遇到的问题重构嘛，肯定会遇到问题。但是qiankun没有太多问题，花费我巨量时间的还是项目中的一些问题，举一两个小例子吧，没太多营养，也不想浪费笔墨。 将公共样式和公共JS逻辑抽取到公共模块后，使用了import-html-entry加载，但是css的加载顺序会变化。如此脆弱的css，顺序变一下最终渲染的就会不同。 公共模块中的postcss解析不对，postcss-nested这个插件，在webpack升级后需要升级，但是升级到最新Version 5会报错，还原到原来Version 1还是还会报错，试着往下降了一版到Version 4，可以work。难受。 脚手架从webpack使用vue-cli后icon，竟然无法展示，具体记录在记一次Icon没展示的bugfix store如何控制，因为是项目拆分，原来公用一个的vuex现在还想维持原状，不想做过多改动，最后使用registerModule将子应用的store注册为主应用的一个module，幸运的是大部分代码都是用getter来获取store中的值，getter的注册具有全局命名空间，无论真是的store是在全局还是子模块。 不想每次都启动N+1个项目，如何处理呢，临时使用npm-run-all来过渡。 权限如何控制？ 其实本来权限也有后端设置的cookie来决定，但是原来是一个spa项目，404页面和* 页面，都需要处理。因为不属于该项目的路由，需要去适配其他的子应用，而不是展示一个404。 子应用之前切换路由，不能使用vue-router的 name，而需要用path。 待解决的问题 不想每次都启动N+1个项目，考虑实现一个类似 import-map-overrides 的工具。可以动态改变publicPath，只启动需要调试的子项目即可。 多个Vue子项目同时启动后，vue-devtool时不时的失效。说不清就加载哪一个项目的状态，我在使用single-spa时没有这个问题。有待深入调查 对于使用镜像来部署的场景，每个镜像中跑一个nginx，里边serve一个html感觉有点浪费，因为js，css，font，img等等全都放cdn上，对于一个三个子项目的项目，每个项目2个节点，有点浪费。 写在最后的话回到最初的愿景，我们还没实现，因为拆分才是我们重构的第一步，下一步要进一步细分，将服务拆的更小，然后才好进行无论是Vue升级，还是UI库升级。 项目上线灰度结束，发现花时间最多的 是处理cookie鉴权 多个项目间路由的处理 并行项目间合并代码 多个项目构建太慢如何优化 为了分析组件间的依赖关系，通过数据说话来决定哪些utils和components需要抽取到公共模块（被依赖太多和被main.js所依赖都需要抽取），自己实现了nodejs脚本来分析webpack的stat文件。通过自动合并代码及查看diff，又写了个nodejs脚本来自动合并。也很有趣。 Reference 飞冰官网：https://ice.work/docs/icestark/about 飞冰作者分享：https://zhuanlan.zhihu.com/p/88449415 qiankun官网：https://qiankun.umijs.org/zh qiankun作者博客：https://zhuanlan.zhihu.com/p/95085796 qiankun作者博客：https://zhuanlan.zhihu.com/p/200775337 https://juejin.im/post/6856569463950639117#heading-15 signle-spa官网：https://single-spa.js.org/","categories":[],"tags":[]},{"title":"5.Vue升级引发nextTick的bug(二)","slug":"5.Vue升级引发nextTick的bug(二)","date":"2021-01-27T03:34:37.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"5.Vue升级引发nextTick的bug(二)/","link":"","permalink":"guguji5.github.io/5.Vue升级引发nextTick的bug(二)/","excerpt":"","text":"nextTick是Vue绕不开的一个方法，nextTick的实现变了，莫名的bug就会出现，再举一个例子。 首先，Vue升级引发nextTick的bug(一)/)提到，Vue2.5.2中的nextTick是宏任务 -&gt; 微任务 -&gt; 宏任务交替触发，先使用宏任务。而Vue2.6.10中nextTick全部使用微任务。 我们的场景是view中有一个form组件，其内部有一个input-number组件。用户填写完信息后submit。 顺便介绍一下input-number，可以参考el-input-number，返回值是数字，当输入其他非法类型时，回弹为上一次有效数字。这一过程会在nextTick中完成。 submit的入参为params {num: string}。为啥num要传string，额~~ 一言难尽。 如何将input-number组件的数字num,转成字符串呢，form组件中有个方法来处理数据transData。 每次reactive的数据变化都会触发nextTick。 所以提交动作的事件流为： submit -&gt; $refs.form.transData() -&gt; axios request 但是，input-number为form的子组件，当子组件值变化时，会改变form中的值，引用传递，不用多讲啦。 所以Vue2.5.2完整的事件流为： submit -&gt; $refs.form.transData() -&gt; axios request -&gt; num回弹为数字 axios的拦截器中是使用promise来处理数据，promise的then为微任务。 而根据上一篇的讨论， num值的变化是在nextTick中完成的。所以当Vue升级成2.6.10，nextTick变成微任务后，事件流为： submit -&gt; num回弹为数字 -&gt; $refs.form.transData() -&gt; axios request 从console中可以看到，在Vue2.5.2中是先axios请求，然后值回弹为数字，所以发送的num为字符串，符合预期。 而升级为Vue2.6.10后，会先回弹，再发送数据，所以发送的num为数字，bug出现。","categories":[],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"guguji5.github.io/tags/Bugfix/"}]},{"title":"4.Vue升级引发nextTick的bug(一)","slug":"4.Vue升级引发nextTick的bug(一)","date":"2021-01-26T10:15:07.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"4.Vue升级引发nextTick的bug(一)/","link":"","permalink":"guguji5.github.io/4.Vue升级引发nextTick的bug(一)/","excerpt":"","text":"最近项目使用qiankun做了个简单的重构和拆分，顺手把Vue版本往上升级了一丢丢（2.5.5 -&gt; 2.6.10)。出现了一点问题，记录之。 简单介绍一下场景，也很简单，就是点击button，出现dialog，而点击其他区域，关闭该dialog，应该是个非常常见的需求。 Vue2.5.2事件流如下: button clicked -&gt; document clicked（冒泡） -&gt; dialog render -&gt; directive bind function 触发 -&gt; document.addEventListener 触发 其中document.addEventListener中的callback，就是关闭该dialog。点击其他区域关闭弹窗，合情合理，符合需求。 代码在Vue2.5.2下工作正常，升级到Vue2.6.10之后，点击button后没有显示dialog，经过各种排查，发现原来是nextTick搞的鬼。 因为click事件是宏任务，如果不清楚可以点击 证明：Click是一个EventLoop宏任务 查看证明过程。 而Vue2.5.2中的nextTick是宏任务 -&gt; 微任务 -&gt; 宏任务交替触发，第一次使用宏任务。而Vue2.6.10中nextTick全部使用微任务。 重新解释一下 Vue2.5.2事件流： button clicked (触发nextTick) -&gt; document clicked（冒泡） -&gt; nextTick 触发（dialog render -&gt; directive bind function 触发 -&gt; document.addEventListener 触发 ） 而根据EventLoop中微任务优先于宏任务执行的逻辑，Vue2.6.10事件流： button clicked (触发nextTick) -&gt; nextTick 触发（dialog render -&gt; directive bind function 触发 -&gt; document.addEventListener 触发 ） -&gt; document clicked（冒泡 触发listener函数）-&gt; callback 触发 关闭dialog 所以表现上弹窗没打开。慢动作是打开了，又关闭了。Bug由此产生。 进一步刨根问题一下为啥会触发nextTick，如果清楚的同学就不用往下看了。先看一下nextTick在不同Vue版本中的注释123456789// Vue 2.5.2// Here we have async deferring wrappers using both micro and macro tasks.// In &lt; 2.4 we used micro tasks everywhere, but there are some scenarios where// micro tasks have too high a priority and fires in between supposedly// sequential events (e.g. #4521, #6690) or even between bubbling of the same// event (#6566). However, using macro tasks everywhere also has subtle problems// when state is changed right before repaint (e.g. #6813, out-in transitions).// Here we use micro task by default, but expose a way to force macro task when// needed (e.g. in event handlers attached by v-on). 123456789101112// Vue 2.6.10// Here we have async deferring wrappers using microtasks.// In 2.5 we used (macro) tasks (in combination with microtasks).// However, it has subtle problems when state is changed right before repaint// (e.g. #6813, out-in transitions).// Also, using (macro) tasks in event handler would cause some weird behaviors// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).// So we now use microtasks everywhere, again.// A major drawback of this tradeoff is that there are some scenarios// where microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690, which have workarounds)// or even between bubbling of the same event (#6566). 首先明确，dialog的打开关闭是用一个data中的变量来控制的，它是reactive的，而button点击打开dialog的过程无非就是将该值设为true，而设置的过程必然会触发defineProperty中的set函数。触发过程如下 set function -&gt; dep.notify() -&gt; subs[].update() -&gt; queueWatcher() -&gt; nextTick() 也就是说每次赋值都会触发nextTick，或者说每次数据的更新后续的变更都是在nextTick中进行的（不知道这么说是不是准确）。 https://unpkg.com/vue@2.5.2/dist/vue.js","categories":[],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"guguji5.github.io/tags/Bugfix/"}]},{"title":"证明：Click是一个EventLoop宏任务","slug":"证明：Click是一个EventLoop宏任务","date":"2021-01-26T01:39:14.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"证明：Click是一个EventLoop宏任务/","link":"","permalink":"guguji5.github.io/证明：Click是一个EventLoop宏任务/","excerpt":"","text":"如题，证明Click是一个EventLoop宏任务JavaScript中事件根据同步异步可以分为哪些类型呢，无非就是 同步（立马执行）和 异步（延迟执行）。而异步又分为宏任务（marcoTask 有的地方也叫Task）和微任务（microTask）。综上，JavaScript中的事件可以分为同步，宏任务和微任务。 EventLoop的讲解可以看看阮一峰博客event-loop或MDN的解释 那么如何证明，Click是一个宏任务呢，它似乎也没有一个定义，那让我们用反证法来证明一下吧。首先让我们看个例子。 https://guguji5.github.io/clickIsMacroEvent/1234567891011121314151617181920212223242526272829&lt;div id=&quot;outter&quot;&gt; outter &lt;div id=&quot;inner&quot;&gt; &lt;span&gt;inner&lt;/span&gt; 点我，猜猜console &lt;/div&gt;&lt;/div&gt;var out = document.getElementById(&apos;outter&apos;)var inner = document.getElementById(&apos;inner&apos;)out.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;outter&apos;) setTimeout(function() &#123; console.log(&apos;this is outter settimeout&apos;) &#125;) Promise.resolve(111).then(res =&gt;&#123; console.log(&apos;this is outter promise&apos;) &#125;)&#125;)inner.addEventListener(&apos;click&apos;, function()&#123; console.log(&apos;inner&apos;) setTimeout(function() &#123; console.log(&apos;this is inner settimeout&apos;) &#125;) Promise.resolve(111).then(res =&gt;&#123; console.log(&apos;this is inner promise&apos;) &#125;)&#125;) 如果Click事件是同步的123456inneroutterthis is inner promisethis is outter promisethis is inner settimeoutthis is outter settimeout 如果Click事件是微任务的1234567// 如果click是微任务，刚开始则 微任务队列中为[inner listener, outter listener]，宏任务队列为[]inner //执行inner的click listener，console.log同步代码立即执行，微任务队列中push进promise的then 为 [outter listener, inner then]，宏任务中push为 [inner setTimeout]outter //执行outter的click listener，console.log同步代码立即执行，微任务队列中push进promise的then 为 [inner then, outter then]，宏任务中再push进setTimeout，为[inner setTimeout, outter setTimeout]this is inner promisethis is outter promise //先情况微任务队列，再执行宏任务this is inner settimeoutthis is outter settimeout 哪个是真的呢，可以试验一下 https://guguji5.github.io/clickIsMacroEvent/显然同步是不对的，毕竟是IO，肯定异步的。如果是微任务，则输出应该是第二种，也不相符，由此得出是宏任务。 如果Click事件是宏任务的123456789// 如果click是宏任务 宏任务队列中为[inner listener, outter listener]，微任务队列为[]inner //执行inner的click listener，console.log同步代码立即执行，微任务队列中push进promise的then 为 [inner then]，宏任务中push进setTimeout 为 [outter listener, inner setTimeout]// 如果是click是一个宏任务，那么应该先清空微任务队列，再执行宏任务，则执行thenthis is inner promise// 微任务队列为空，执行一个宏任务task：outter listeneroutter //执行outter的click listener，console.log同步代码立即执行，微任务队列中push进promise的then，宏任务中再push进setTimeout，为两个setTimeoutthis is outter promise //先情况微任务队列，再执行宏任务this is inner settimeoutthis is outter settimeout https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoophttp://www.ruanyifeng.com/blog/2014/10/event-loop.html","categories":[],"tags":[]},{"title":"3.Referer理解错误导致的跨域","slug":"3.Referer理解错误导致的跨域","date":"2021-01-21T11:54:06.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"3.Referer理解错误导致的跨域/","link":"","permalink":"guguji5.github.io/3.Referer理解错误导致的跨域/","excerpt":"","text":"在前后端分离的情况下，大多数请求都是跨域请求。 组里的Nodejs Koa服务CORS不知道在网上参考哪个倒霉博客，在Referer上取CORS的值，差不多代码如下： 1ctx.set(&apos;Access-Control-Allow-Origin&apos;, ctx.header.referer.slice(0, -1)); Referer 有个规则，#之后的会丢掉（e.g. #section),顺便说一句鉴权的也不行（e.g. https://username:password@example.com)。Currently 单页应用大行其道，hash路由下，只会返回Origin。 Referer为 https://app.example.com/ 时把CORS设为 https://app.example.com。刚开始岁月安好，符合预期。 问题出在当用户访问 https://app.example.com/page.html 时请求 https://api.example.com/getData，跨域了，。在不同浏览器下（严谨点说是不同的 Referrer-Policy下）会展示为 12345no-referrer-when-downgrade https://app.example.com/page.htmlorigin-when-cross-originhttps://app.example.com/ 在之前默认值为 no-referrer-when-downgrade,悄咪咪的，谷歌粑粑把默认值改成了 strict-origin-when-cross-origin。这导致所有跨域网站的Referer都会变成Origin。 Chrome plans to switch its default policy from no-referrer-when-downgrade to strict-origin-when-cross-origin, starting in version 85.（From developers.google.com) However，safari浏览器还是no-referrer-when-downgrade，这意味着尽管同一个页面，referer可能在 safari下为 https://app.example.com/page.html 而在chrome下为 https://app.example.com/,所以用Referer是个愚蠢的选择，改成使用Origin来判断。 123if (/^(.+?)\\.example\\.com$/.test(ctx.header.origin)) &#123; ctx.set(&apos;Access-Control-Allow-Origin&apos;, ctx.header.origin);&#125; Referencehttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Refererhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policyhttps://developers.google.com/web/updates/2020/07/referrer-policy-new-chrome-default","categories":[],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"guguji5.github.io/tags/Bugfix/"}]},{"title":"2.记一次Icon没展示的bugfix","slug":"2.记一次Icon没展示的bugfix","date":"2020-12-23T09:49:28.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"2.记一次Icon没展示的bugfix/","link":"","permalink":"guguji5.github.io/2.记一次Icon没展示的bugfix/","excerpt":"","text":"滴滴云控制台为了升级vue，UI库和脚手架，使用qiankun做了拆分。拆分后的发现Icon的展示有问题。 项目结构如下1234567|____node_modules| |____ui-lib| | |____index.css| | |____fonts| | | |____ui-lib.woff|____src| |____main.js main.js1import &apos;ui-lib/index.css&apos; node_modules中的ui-lib1@font-face&#123;font-family:ui-lib;src:url(fonts/ui-lib.woff) format(&quot;woff&quot;)&#125; vue.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344const publicPath = process.env.NODE_ENV === &quot;production&quot; ? &apos;//cdn.myservice.com/&apos; : `/`;module.exports = &#123; publicPath, configureWebpack: &#123; entry: &#123; app:&apos;./src/main.js&apos;&#125;, module: &#123; rules: [ &#123; test: /\\.css$/, exclude: /node_modules/, use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; postcssOptions: &#123; &#125;, execute: true, &#125;, &#125;, ], &#125;, ], &#125;, &#125;, chainWebpack: config =&gt; &#123; const imgRule = config.module.rule(&apos;images&apos;); imgRule.uses.clear(); imgRule .use(&apos;file-loader&apos;) .loader(&apos;file-loader&apos;) .options(&#123; name: &apos;img/[name].[hash:8].[ext]&apos;, publicPath &#125;) .end() &#125;, &#125; 编译后的文件app.css1@font-face&#123;font-family:ui-lib;src:url(../fonts/ui-lib.woff) format(&quot;woff&quot;)&#125; 这里变成了../fonts/ui-lib.woff,而没有变成预期的cdn.myservice.com/fonts/ui-lib.woff。所以浏览器加载的时候path报错了。我最先尝试的是在configureWebpack.module.rules增加url-loader12345678&#123; test: /\\.(woff?|eot|ttf|otf)(\\?.*)?$/, loader: &apos;url-loader&apos;, query: &#123; limit: 2048, name: &apos;fonts/[name].[hash:7].[ext]&apos; &#125;&#125;, 结果顺利的被解析成了base64。而base64的内容是module.exports = __webpack_public_path__ + &quot;node_modules/ui-lib//fonts/ui-lib.b3909f8.woff&quot;;虽然浏览器调试台里preview展示如下，但是Icon仍然没展示出来。(这里为什么展示出来，但是没生效我也没想明白) 项目是vue-cli搭建的，其实非常困惑的是 const imgRule = config.module.rule(&#39;images&#39;);这里的images是代表什么，又没定义过，只好去翻vue-cli的文档这里忍不住想吐槽一下vue-cli，为了简化上手成本，它默认内置了常用的loader和plugin，但是没有暴露出来。webpack的配置进到@vue/cli-service的项目中都看不到webpack的配置。根据文档，vue inspect &gt; output.js。可以把所有内置的webpack信息输出出来。 1234567891011121314151617181920212223242526272829303132➜ demo git: ✗ vue inspect --rules[ &apos;vue&apos;, &apos;images&apos;, &apos;svg&apos;, &apos;media&apos;, &apos;fonts&apos;, &apos;pug&apos;, &apos;css&apos;, &apos;postcss&apos;, &apos;scss&apos;, &apos;sass&apos;, &apos;less&apos;, &apos;stylus&apos;, &apos;js&apos;, &apos;eslint&apos;, &apos;Nameless Rule (*)&apos;]➜ demo git: ✗ vue inspect --rule fonts/* config.module.rule(&apos;fonts&apos;) */&#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, use: [ &#123; loader: &apos;file-loader&apos;, options: &#123; publicPath: &apos;/&apos;, name: &apos;fonts/[name].[hash:8].[ext]&apos; &#125; &#125; ]&#125; 同上例的config.module.rule(‘fonts’)一样，images也是对图片适用的loader配置，这猜破了脑袋也猜不出来（小声比比）。这页文档太宝贵了，这个问题迟早得遇到，早遇到早明白。 能解决问题的配置12345678 config.module.rule(&apos;fonts&apos;).test(/\\.(woff2?|eot|ttf|otf)(\\?.*)?$/).use(&apos;url-loader&apos;).loader(&apos;file-loader&apos;).options(&#123; publicPath, name: &apos;fonts/[name].[hash:8].[ext]&apos;&#125;) 上边的配置强行解释一波，把fonts的规则，test改为/\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,把原来fonts的url-loader改为带options的file-loader。 顺手把woff文件刨了一下，扔到解析网站，发现它是如下的样子 具体为什么在content里写上对应的code，就展示出了对应的icon。我也没搞懂。","categories":[],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"guguji5.github.io/tags/Bugfix/"}]},{"title":"SameSite的解释和跨域cookie问题的解决","slug":"cross-site-cookies","date":"2020-11-01T12:14:41.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"cross-site-cookies/","link":"","permalink":"guguji5.github.io/cross-site-cookies/","excerpt":"","text":"问题提出现在大多项目的前后端都是分离的，部署在不同的 IP 及域名上，之前遇到一个测试环境的问题，虽然解决了但一直不明所以。前端项目测试环境部署在 10.155.18.1 环境的 8080 端口，而后端项目测试环境部署在 10.155.19.2 环境的 8126 端口，通过 sso 登录后回调后端的接口中 Set-Cookie 一个 q 字段来给前端保持登录的状态。但是，后续的后端请求都没有带上该 cookie，在浏览器的本地缓存中查看该 cookie 也是存在的。问题就是为啥明明设置了，后续请求却丢失了该 cookie。 我猜想 cookie 在 IP 上是不是有什么问题，我就本地配了两个 host，分别为 1210.155.18.1 mis.example.io10.155.19.2 api.example.io 通过mis.example.io:8080来访问，回调api.example.io:8126，cookie 中的 q 会一直带着。一直想不通，这域名跟 IP 有啥不同，反正都是跨域。为啥用 IP 不行，用域名就可以了呢？ 直到看到了samesite-cookies-explained，了解到了 samesite 对 cookie 的限制。文章讲了 cookie 的由来，因为 http 协议是无状态的，而 cookie 可以使状态持久化，通过 key=value 的状态来使用，通过 headers 中的 Set-Cookie 来进行设置等等 cookie 的基本概念（这些大家都知道，而跟题目无关） 什么是 first-party 和 third-party 的 cookie？让我们举个例子，你可能会注意到一个网站不仅仅是当前你正在访问的域名，而是有很多不同域名的 cookies 组成。Cookies 会匹配当前网站（在浏览器地址栏的网址）会被认为 first-party cookies，类似的，来自其他域名的 cookies 则被认为 third-party cookies，这不是一个绝对的概念，它会根据用户访问的站点来变化。同一个 cookie 根据当前访问站点的不同，可能会被认为 first-party 或者 third-party。 让我们继续上边的例子，假如你的博客上有一个非常迷人的猫咪图片，它被托管在/blog/img/amazing-cat.png。因为它非常的特别，所以其他人会直接把地址放在自己的网站里（其实上图我就是直接粘的原博客的链接）。当有访客访问你的博客时，有一个promo_shown的 cookie（在原网站中可能是用来控制弹出框是否展示），然后他访问其他人的网站时，也会带上这个 cookie，但它在其网站上可能没有任何意义，所以有些多余。 如果这是一个意想不到的效果，你为什么要这样做呢?当站点在第三方上下文中使用时，正是这种机制允许站点维护状态。例如，如果你在你的网站上嵌入一个 YouTube 视频，那么访问者将会在播放器中看到一个“稍后观看”的选项。如果访问者已经登录了 YouTube,该有效期的会话会使用第三方嵌入式播放器 cookie，这意味着“稍后观看”按钮将保存视频,而不是弹出对话框提示他们去注册或者迫使用户离开你的页面并导航到 YouTube。 网络最大的特性就是开放，这也是许多人去创造和记录 blog 的原因之一，然而这也会带来一些安全和隐私方面的问题。CSRF（跨站请求伪造）的实现依赖于 cookie 的这一属性，无论谁发起的请求，它都会被携带在 http 请求上。为了更好的解释 third-party，再举一个例子，当你访问evil.example时，它会向your-blog.example发起请求，然后浏览器自然而然的会带上对应的 cookie，如果你的博客网站没有很好的验证和处理好它，那么这些请求就会做一些危险操作，比如删除博文，或者添加一些“evil”想要的内容。 用户也越来越了解如何使用 cookie 在多个站点跟踪他们的活动。然而，到目前为止，还没有一种方法可以明确地说明使用 cookie 的意图。 使用 SameSite 属性来明确 cookie 的使用范围定义在RFC6265bis的SameSite允许我们声明 cookie 可以用来 first-party 或者 same-site。它会明确的给出“网站”是指哪些（哪些可以带 cookie）。网站由域名后缀和域名前部分组成，比如www.web.dev是web.dev的一部分。 关键概念当用户在网站www.web.dev，向static.web.dev请求一个图片，这是一个same-site请求。 不仅仅是顶级域名例如.com，也包括了一些公共服务github.io。有一个公共后缀名单定义了 sameSite 的范围，这使的your-project.github.io和my-project.github.io为两个站点，也就是跨域。SameSite属性提供了三种不同的方式来管理 cookie，你可以不指定这个属性（None），或者使用Strict和Lax来限制 cookie 的 same-site 请求。 Strict如果SameSite设置为Strict，则 cookie 只能在 first-party 的内容中传输，在用户的层面，只有当访问的 url 匹配 cookie 的站点时才会带上 cookie。可以如下设置： 1Set-Cookie: promo_shown=1; SameSite=Strict 当用户通过一个链接进入你的网站，或者说从从有个你朋友发来的邮件链接中点开网站，cookie 不会起作用。这对于那些有功能性的 cookie（修改密码或者下单）很有益处，但是对于promo_shown这种仅仅用来展示弹出框的 cookie 来说有点过于限制了。 Lax还记得迷人猫咪的图片么，假如猫咪的图片被人直接放在他的网站，并且放了一个链接在文章中，如下： 123&lt;p&gt;Look at this amazing cat!&lt;/p&gt;&lt;img src=&quot;https://blog.example/blog/img/amazing-cat.png&quot; /&gt;&lt;p&gt;Read the &lt;a href=&quot;https://blog.example/blog/cat.html&quot;&gt;article&lt;/a&gt;.&lt;/p&gt; cookie 会被这样设置 1Set-Cookie: promo_shown=1; SameSite=Lax 当读者打开他的网站时，请求amazint-cat.png的时候不会带上 cookie，然而当用户点击链接，进入你博客时，cookie 会被使用。对于仅仅影响展示的 cookie 来说 Lax 是一个不错的选择。 None将SameSite设置为None意味着，你明确的表示，在 third-party 发送请求时使用 cookie，你很清楚这样做的收益和后果。 1Set-Cookie: widget_session=abc123; SameSite=None; Secure 最后两点 没有设置SameSite会被认为SameSite=Lax 当设置SameSite=None时，必须同时设置Secure 谷歌浏览器在 version 84 默认开启该特性，火狐浏览器 69 可以再about:config中设置network.cookie.sameSite.laxByDefault来体验该特性。Edge 浏览器计划将该特性设为默认。 相信看到这，最开始的问题，也有了答案了吧。 参考链接samesite-cookies-explainedhttps://www.chromestatus.com/feature/5088147346030592","categories":[],"tags":[]},{"title":"信封弹出特效(可能是从业以来最复杂的效果)","slug":"信封弹出特效-可能是从业以来最复杂的效果","date":"2020-09-29T06:09:41.000Z","updated":"2021-08-01T01:30:09.000Z","comments":true,"path":"信封弹出特效-可能是从业以来最复杂的效果/","link":"","permalink":"guguji5.github.io/信封弹出特效-可能是从业以来最复杂的效果/","excerpt":"","text":"作为一个前端，也是希望可以实现各种炫酷的效果的，比如3D效果，但是一直供职于toB的公司，实现炫酷效果的机会很少，这个信封弹出可能是从业以来实现的最复杂的一个效果。设计给的效果如下： 刚开始心里一慌，先把其他表单，表格，弹窗等简单的实现完以后，再来冷静的分析了一波。其实设计给的效果和日常我们打开信封的动作是一样的，所以不存在理解的上的成本。将mp4慢放后分析后，发现信封的上，下，前 以及信纸都会动，还有信封上的徽章和button都有渐变和移动效果，所以需要将信封的拆成各个部分，分别做绝对定位。 动画 点击”敬启”后高亮，并向上移动10px 整个信封向下平移100px “敬启”消失，滴滴云logo消失 信封上半部沿Z轴向外旋转180度，同时z-index下降，信封正面慢慢向下 信封下半部分沿Z轴转动小幅度 信纸弹出，”随便看看”淡入 还有一个点需要注意，刚开始是信封上边压着信封下边，一起压着信纸，但是弹开后信纸需要压在信封上面。所以就需要z-index的变化。 因为信封是有多个图片构成，所以首次展示会出现展示慢的情况,如下图，信纸先于信封展示出来，不符合预期，需要优化。 优化思路： 信纸内元素有文案和icon，而信封图片较大，所以一方面先将信纸隐藏，信封打开前再展示 信封图片有1.1M，压缩之 大图片存放cdn 预览效果链接：https://guguji5.github.io/envelop-popup/","categories":[],"tags":[]},{"title":"1.记一次koa转发请求遇到的bug","slug":"1.记一次koa转发请求遇到的bug","date":"2020-07-18T11:50:39.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"1.记一次koa转发请求遇到的bug/","link":"","permalink":"guguji5.github.io/1.记一次koa转发请求遇到的bug/","excerpt":"","text":"最近公司内某业务线清理非法请求，options请求就被归为此类，从浏览器端直接调用跨域的api必然产生options，所以需要proxy来转发。 无论对于何种后端语言来说，转发都是一个基本切正常的需求，我们选择使用前端自己搭的nodejs server来做转发。在调研了 koa-proxy，koa-proxies，koa-better-http-proxy，koa2-proxy-middleware等，选择了koa-proxies。用法简单，配置清晰。 12345678// middlewareapp.use(proxy(&apos;/octocat&apos;, &#123; target: &apos;https://api.github.com/users&apos;, changeOrigin: true, agent: new httpsProxyAgent(&apos;http://1.2.3.4:88&apos;), // if you need or just delete this line rewrite: path =&gt; path.replace(/^\\/octocat(\\/|\\/\\w+)?$/, &apos;/vagusx&apos;), logs: true&#125;)) 可是一直超时，看了koa-proxies源码后，在其node-http-proxy里边打了断点，有输出如下报错12345678910&#123; Error: socket hang up at createHangUpError (_http_client.js:342:15) at Socket.socketOnEnd (_http_client.js:437:23) at emitNone (events.js:111:20) at Socket.emit (events.js:208:7) at endReadableNT (_stream_readable.js:1064:12) at _combinedTickCallback (internal/process/next_tick.js:139:11) at process._tickCallback (internal/process/next_tick.js:181:9) code: &apos;ECONNRESET&apos;&#125; 在node-http-proxy的issue里查了好久好久，经 koa2-proxy-middleware 文档提醒，将bodyParser挪到proxy后解决问题。具体对比demo如下： 12345678910111213// this works well.const Koa = require(&apos;koa&apos;);const app = new Koa();const proxy = require(&apos;koa-proxies&apos;)const bodyParser = require(&apos;koa-bodyparser&apos;);app.use(proxy(&apos;/user&apos;, &#123; target: &apos;http://example.com&apos;, changeOrigin: true, rewrite: path =&gt; path&#125;))app.use(bodyParser())app.listen(8080); 1234567891011121314// this works with bug &quot;socket hang up&quot;.const Koa = require(&apos;koa&apos;);const app = new Koa();const proxy = require(&apos;koa-proxies&apos;)const bodyParser = require(&apos;koa-bodyparser&apos;);app.use(bodyParser())app.use(proxy(&apos;/user&apos;, &#123; target: &apos;http://example.com&apos;, changeOrigin: true, rewrite: path =&gt; path&#125;))app.listen(8080); 这个proxy，真的是 从查找文档，拷贝粘贴，一共也就用了5分钟。但是把bodyParser从proxy上边挪到proxy下边用了many many多的hours。这事不能这么过了，必须得找下原因看看为啥。 先从 koa-bodyparser 这个库说起吧，它到期对api请求过来的数据做了什么？我们都知道这个库是在koa框架下解析post put等有请求体的api时，将请求体数据转换成我们想要的格式，比如json，form，text等。那么它是如何做的呢？我们举一个最简单的nodejs例子来如何处理post数据1234567891011121314http.createServer(function (req, res) &#123; console.log(req.url) let postData = &apos;&apos; req.on(&apos;data&apos;, chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on(&apos;end&apos;, () =&gt; &#123; if (postData) &#123; res.setHeader(&apos;Content-type&apos;, &apos;text/plain&apos;) res.end(&apos;request successfully proxied!&apos; + &apos;\\n&apos; + JSON.stringify(req.headers, true, 2) + postData) &#125; console.log(JSON.parse(postData)) &#125;) &#125;).listen(9000); 很显然在bodyParser这个中间件中消费了data数据，直到它结束。而middleware会串行的一个一个执行，并且修改ctx中的res和req。 再到proxy这个中间件执行时req中就没有data事件了。 这和使用postman请求的结果符合，使用postman请求是一直不返回数据，其实它被bodyParser接受并消费了，根本没发到proxy的target去，也就没有返回值可言了，超时后报错hang up,一切就通了。 这次浪费这么多时间主要还是对middleware和bodyParser这个库的实现不熟悉，继续加油吧。","categories":[],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"guguji5.github.io/tags/Bugfix/"}]},{"title":"JavaScript策略模式浅析","slug":"JavaScript策略模式浅析","date":"2020-06-04T06:26:22.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"JavaScript策略模式浅析/","link":"","permalink":"guguji5.github.io/JavaScript策略模式浅析/","excerpt":"","text":"策略模式封装了针对 特定任务 的可选策略。在客户端（使用方）无感的前提下，它允许一个方法在运行时 切换 成任何其他策略。本质上，策略是一组可互换的算法。 例1. 算法效率假设要测试不同排序算法的性能，包括希尔排序，堆排序，冒泡排序，快速排序等。应用策略模式，可以将测试代码循环所有的算法。我们可以在运行时更改数组中的每一个算法。为了使策略模式生效，所有的算法参数必须相同，这使得算法可以变换，而对测试程序无感。 测试算法效率是Context，不同的算法是不同的Strategy。算法可以测试人的需求来变更。 例2. 快递计费在本例中，我们有一个产品订单，需要从仓库发货给客户。对不同的快递公司进行评估，以确定最优价格。这对于购物车非常有用，在购物车中，客户可以选择自己的运输偏好，所选择的策略返回估算的成本。 运输是Context，三家快递公司顺丰，EMS, 和圆通是Strategy。货运(策略)改变了3次，每次我们计算快递成本。在真实的场景中，计算方法可能调用快递公司的Web服务。最后我们显示了不同的成本。 策略模式组成1. Context在例2中，寄快递这件事是Context，他有三个特性： 可以获取当前策略的引用（比如出发地信息，目的地信息，包裹重量等等） 根据不同策略计算不同价格 允许用户选择不同的快递公司 2. Strategy实现算法的接口 策略模式流程图 show me your code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var Shipping = function() &#123; this.company = &quot;&quot;;&#125;; Shipping.prototype = &#123; setStrategy: function(company) &#123; this.company = company; &#125;, calculate: function(package) &#123; return this.company.calculate(package); &#125;&#125;; var UPS = function() &#123; this.calculate = function(package) &#123; // calculations... return &quot;$45.95&quot;; &#125;&#125;; var USPS = function() &#123; this.calculate = function(package) &#123; // calculations... return &quot;$39.40&quot;; &#125;&#125;; var Fedex = function() &#123; this.calculate = function(package) &#123; // calculations... return &quot;$43.20&quot;; &#125;&#125;; // log helper var log = (function() &#123; var log = &quot;&quot;; return &#123; add: function(msg) &#123; log += msg + &quot;\\n&quot;; &#125;, show: function() &#123; alert(log); log = &quot;&quot;; &#125; &#125;&#125;)(); function run() &#123; var package = &#123; from: &quot;76712&quot;, to: &quot;10012&quot;, weigth: &quot;lkg&quot; &#125;; // the 3 strategies var ups = new UPS(); var usps = new USPS(); var fedex = new Fedex(); var shipping = new Shipping(); shipping.setStrategy(ups); log.add(&quot;UPS Strategy: &quot; + shipping.calculate(package)); shipping.setStrategy(usps); log.add(&quot;USPS Strategy: &quot; + shipping.calculate(package)); shipping.setStrategy(fedex); log.add(&quot;Fedex Strategy: &quot; + shipping.calculate(package)); log.show();&#125; links:https://www.dofactory.com/javascript/strategy-design-patternhttps://refactoringguru.cn/design-patterns/state","categories":[],"tags":[]},{"title":"滴滴云MIS Single-spa微服务化项目总结","slug":"Single-spa微服务化前端项目总结","date":"2020-05-30T07:42:15.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"Single-spa微服务化前端项目总结/","link":"","permalink":"guguji5.github.io/Single-spa微服务化前端项目总结/","excerpt":"","text":"我们为什么要用微前端 ？当然微前端的优势有很多，具体到我们应用大概就以下三点： 因为滴滴云有三个项目，滴滴云官网，滴滴云控制台，滴滴云MIS。滴滴云官网和控制台是对外提供服务，MIS是对内提供服务。MIS如何复用控制台和官网的组件？在单页应用的架构下，目前没有能力，从去年冬天，我们开始探索微前端的结构。 MIS中功能较为独立，一部分模块改动频繁，另外一些可以说基本不更新。作为一个整体应用，这些原本不需要改动的代码既增加了整体编译，发布，开发时热部署的耗时，多个功能并行开发，也增加了产生BUG的可能性。 前端技术栈更迭非常快，微前端可以让我们更自由的选择我们感兴趣的，更新更强的技术栈及配套。 所以我们决定拆分MIS，一方面做优化，另一方面为滴滴云控制台这个庞然大物探索一个解决方案。 Why single-spa ?其实微前端的实现方案有很多，这方面无论Way社区还是掘金知乎上讲的很多了。我们不想失去单页应用优秀的用户体验，不想去触碰容易导致各种诡异问题的iframe，也不想去尝试目前兼容性还有待提高的Web Components。在我们体验了single-spa 在线demo，开箱即用的脚手架，再加上其核心团队快速的响应能力，我们决定试水single-spa。 打动我的还有作者文档上的一段话 : single-spa takes inspiration from modern framework component lifecycles by applying lifecycles to entire applications. It was born out of Canopy’s desire to use React + react-router instead of being forever stuck with our AngularJS + ui-router application, and now single-spa supports almost any framework. Since JavaScript is notorious for the short-life of its many frameworks, we decided to make it easy to use whichever frameworks you want. 这正是在我之前公司遇到的困境，如何把AngularJS升级到Angular 5.0 ，简直是雷锋和雷峰塔的区别。我们选择了重写了项目，新旧项目双线作战，而single-spa的做法却别出心裁。 使用single-spa我们需要了解什么首先简单看一下single-spa重构项目的结构，有一个基座html，多个子应用按需插入基础，不需要的子应用，从基座拔出。 在了解single-spa本身Api之前，我觉得有必要了解一下SystemJs，import maps的使用，不同构建版本包的使用)。single-spa的核心团队的Joel Denning录了一系列讲解视频在YouTube和Bilibili，非常推荐。 实施single-spa遇到的问题 子应用打包格式错误single-spa 加载子应用的库是systemjs,并不是所有的js文件都可以加载，推荐使用 libraryTarget: &#39;system&#39;,umd 和 amd 亦可。参考链接了解更多Now, there are also various other formats and working with them all is a pain so systemjs has the ‘extras’ it uses in order to interop between them. umd and amd are good formats because they’re designed to work in the browser. But that means there’s a layer to unwrap/interop with so system should be preferred if possible.( from Carlos ) 跨域问题这应该是single-spa开发中一定会遇到的一个问题，因为同时启动多个项目肯定在localhost的不同端口，将不同端口的服务加载到root-html中势必会跨域，所以解决它就好了。需要在webpack配置中中添加&quot;Access-Control-Allow-Origin&quot;: “*”即可。 single-spa 子应用挂载时把挂载的dom节点替换掉？拿single-spa-vue为例，1.7.0 会把挂载节点替换掉。而1.8.0 会把挂载节点保留。根据自己的需要选择版本，可以在package-lock.json中锁定版本。 single-spa 的项目如何部署在nginx服务器？single-spa，顾名思义，还是一个单页应用。我们不希望切换路由的时候浏览器发生跳转或者刷新。可以尝试如下配置： 123location / &#123; try_files $uri $uri.html /index.html =404; &#125; System-importmap 存在哪里，如何修改？根据官方的推荐，importmap建议存在S3存储，目前我们使用的内部gift服务，gift上目前没有一个支持https协议的域名，所以使用了cdn的域名。但这个cdn的下发有延迟，导致页面的刷新有些问题，后期考虑存到数据库。 有关public path，external 和 systemjs-webpack-interop的解释首先publicPath是配置项目中所有资源的一个基础路径；externals提供了运行时从外部获取依赖的方法，external可以接受多种模块类型的资源；systemjs-webpack-interop是一个搭配single-spa使用的组件，提供了简单方便修改运行时publicPath的方法。了解更多相信下边的链接一定能让你搞明白这两个概念。https://www.webpackjs.com/configuration/externals/https://www.webpackjs.com/guides/public-path/#on-the-flyhttps://github.com/joeldenning/systemjs-webpack-interophttps://stackoverflow.com/questions/28846814/what-does-publicpath-in-webpack-dohttps://tomasalabes.me/blog/web-development/2016/12/11/Webpack-and-the-public-path.html 多个子应用共同依赖的css，组件如何共享，权限如何控制，全局状态如何维护？根据官方的推荐，可以专门创建一个子应用来做这些事，公共样式，封装http服务，一些不想暴露在全局的状态也可以在这个应用里维护。这个模块可以配合external被其他模块引用。了解更多https://single-spa.js.org/docs/faq/#how-can-i-share-application-state-between-applications Css 冲突怎么解决呢？ Namespace the CSS belonging to each app with a class, and wrap the app in that container class (such as BEM). Use CSS modules in your components https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/( https://vue-loader.vuejs.org/guide/css-modules.html#usage) Use a CSS-in-JS library like https://styled-components.com/ The ‘scoped’ attribute in style tag我选的第一种，postcss-plugin-namespace 可以方便的将项目中所有的postcss 加一个prefix，成本很小。其他的都需要改造代码。 不同子应用切换的时候白屏如何解决？一种思路使用预加载；另一种思路是在侦测到有新应用加载时增加一个loading的过渡页；我选第二种。single-spa api文档 提供了 single-spa:before-app-change 和 single-spa:app-change 事件，可以在两个事件中间增加一个loading。(single-spa 5.5.0版本才支持，具体请见issue) 一个完整spa项目想放入single-spa要做什么更改？根据官方的推荐,需要两步。一，实现single-spa所需要的bootstrap，mount，unmount等生命周期钩子函数。二，保证你的外部链接报错css，JavaScript等可以独立工作。 除此之外 ，如果你使用了webpack抽取了很多chunk，这可能会导致失败，因为不同的chunk包不会加载其他依赖的包。Joeldenning建议按路由懒加载进行拆包。 子应用如何部署，上线时如何更新importMap？微前端的子应用可以独立部署，目前经过OE打包后，在弹性云或odin部署；目前importMap存储在gift，但是弹性云现有的镜像没有提供部署完后继续shell脚本的执行，所以自己做了一个镜像 registry.xiaojukeji.com/didionline/didiyun-mis-nginx-main:stable，它只不过在内部拉起nginx服务后，执行了一个shell脚本，它会更新gift链接中的内容。 不同子应用访问路径如何配置？不同的子应用跑在不同的弹性云节点，可以通过不同的子域名来进行映射，odin的微前端就是采用这种方案。也可以通过不同的path映射到不同的ip机器上，地图团队的微前端使用的这种方案。我选的后者。12345678upstream misaccount &#123; server 10.1.2.3:8080; server 10.4.5.6:8080;&#125;location /mis-account/ &#123; proxy_pass http://misaccount/;&#125; 收益 探索了使用single-spa的成本和难度，为改造滴滴云控制台提供了一种解决方案。 拆分后的项目更独立，为技术栈的改造和升级降低了门槛。 最最重要的给复用滴滴云控制台的代码提供了一种可维护的方案，目前滴滴云MIS中费用中心使用的是滴滴云控制台中现成的视图组件。 改版后的MIS懒加载更合理，不同的用户使用MIS中某些特定的功能，真正做到不使用的应用不加载。 给团队的同学分享和实践了一种可落地的微前端解决方案。 全新的开发体验，做到开发哪里，替换哪里。(import-map-overrides新体验) 写在最后的话single-spa核心团队的Joeldenning是一个非常热情，阅历丰富，技术扎实的开发人员。在探索single-spa的过程中，向他学习到很多东西，他也总是能第一时间给出合理的解决方案，并且也是很热心的把再Youtube上的single-spa的介绍视频上传到bilibili一份，投桃报李，我们团队也利用周末时间，进行了single-spa的中文翻译工作，收获良多。","categories":[],"tags":[{"name":"微前端 single-spa","slug":"微前端-single-spa","permalink":"guguji5.github.io/tags/微前端-single-spa/"}]},{"title":"前端需要知道的nginx知识","slug":"前端需要知道的nginx知识","date":"2020-05-08T08:12:53.000Z","updated":"2021-08-01T01:30:04.000Z","comments":true,"path":"前端需要知道的nginx知识/","link":"","permalink":"guguji5.github.io/前端需要知道的nginx知识/","excerpt":"","text":"看来我必须得写点前端需要掌握的nginx知识了，每次都浪费我好多好多的时间。 1. proxy_pass具体的可以见 https://blog.csdn.net/u010433704/article/details/99945557 这个链接，使用场景是，当我们有很多机器，但是只有一个域名时，可以通过不同的location来转发到不同的机器上。 2. gzip有关gzip的介绍，可以参考这个如何使用GZIP来优化你的网站，在nginx开启gzip很简单，但是proxy_pass 和 gzip配合起来，有些好坑，https://reinout.vanrees.org/weblog/2015/11/19/nginx-proxy-gzip.html 这个链接解释了如何操作。 3. upstream 负载均衡nginx的一个重要功能就是负载均衡，可以使用upstream来实现。负载均衡的策略可以有很多种，hash，requestUrl，轮询等待。12345678910111213141516171819202122upstream helloworld &#123; server 10.133.25.1:8080; server 10.160.60.75:8080;&#125;server &#123; listen 8080; server_name www.example.com; root /home/demo/public; location / &#123; add_header Access-Control-Allow-Origin *; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, OPTIONS&apos;; try_files $uri $uri.html /index.html =404; &#125; location /home/ &#123; proxy_pass http://helloworld/; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"guguji5.github.io/tags/nginx/"}]},{"title":"vue-cli4加载css重复？","slug":"vue-cli4加载css重复？","date":"2020-03-13T03:26:24.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"vue-cli4加载css重复？/","link":"","permalink":"guguji5.github.io/vue-cli4加载css重复？/","excerpt":"","text":"vue-cli引入css的正确姿势是什么？ vue-cli怎么避免重复引入css呢？ 问题最近用single-spa尝试重构项目,每个子项目用vue-cli初始化，瞧了一眼vue-cli都已经第四版了。我的css预编译框架选的less，本计划是像之前一样直接在main.js中直接 import &#39;./styles/index.less&#39;; 报错了（但是错误是啥不记得了），查了vue-cli的文档CSS 相关 可以选择 style-resources-loader 和 vue-cli-plugin-style-resources-loader 来引用资源。（见下图一） 结果在debug样式的时候发现样式重复引入了，啥叫重复了呢，就是像下边这个样子，明明是同一段css，却被加载了N多次。 原来 vue-cli-plugin-style-resources-loader 是会在每个vue文件中都注入依赖的代码，一般只把less变量放进去。像我这边这样，把的入口index.less文件都引进去，相当于在每个文件中都import了index.less一遍。 1234567//vue.config.js 图一pluginOptions: &#123; 'style-resources-loader': &#123; preProcessor: 'less', patterns: [path.resolve(__dirname, 'src/styles/index.less')] &#125; &#125; 12345678//vars.less 图二@blue-base: #2D77EE;@blue-light: #6C9FF3;@blue-middle-light: #DDE9FC;@blue-extra-light: #F3F7FE;@blue-lightest: #E4E5EA;@blue-active: #2A6BD4;@base-color: @blue-base; 结论 全局less样式，可以在main.js中通过import引入，需要less变量的文件手动@import vars.less，比较清楚明白。 单独使用 style-resources-loader 可以按图一的方式将index.less文件的作为样式入口文件引入，不会重复。注意一定不要安装 vue-cli-plugin-style-resources-loader 组件。 style-resources-loader 和 vue-cli-plugin-style-resources-loader 同时安装时，vue.config.js 中只能引入变量（如图二）。 比较推荐的方法是，index.less在main.js中引入，vars.less 等变量在vue.config.js中引入。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"guguji5.github.io/tags/CSS/"}]},{"title":"fork项目自动同步机器人","slug":"fork项目自动同步机器人","date":"2020-02-29T12:14:28.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"fork项目自动同步机器人/","link":"","permalink":"guguji5.github.io/fork项目自动同步机器人/","excerpt":"","text":"调研了一段时间微前端，发现single-spa的实现很简单清晰，就把它当做主要解决方案使用在项目中，加入其Slack后，single-spa的作者有问必答，着实让人感动，所以在其提出能否帮翻译single-spa的文档时，我也没有推辞。翻译的过程，也是一个详细了解的过程，认真求索的过程。 脚本在参考了react团队的翻译经验后，需要有个同步机器人，具体来讲就是当英文版文档更新后，需要同步到其他语言的文档。 本来以为很难，就去看react翻译团队的同步机制。很简单，却有一个问题，log没有存储，无法查看运行的状况，而这点log4js本身是支持的。支持了log本地输出的问题，缺引发了另一个问题，process.exit会中断log4js日志的写入。尝试了网上的几种解决方案后，如监听beforeExit事件和process.exit后通过异步事件输出log都不可信，nodejs的文档也写的非常清楚。 1在调用 &apos;exit&apos; 事件监听器之后，Node.js 进程将立即退出，从而导致在事件循环中仍排队的任何其他工作被放弃。 所以，只好对条件进行通过IF ELSE来判断以保证所有的log都能正常输出，带来的副作用就是没有之前可读性强，\b后序有时间我再调研一下。 首先需要将待翻译仓库 git clone 到本地，然后使用git remote add将英语文档的地址添加为远端仓库。 具体同步的流程如下图，so easy。 直接提交，会以single-spa-bot账户直接向翻译的仓库直接提交。具体就像这样。 而冲突后，会将冲突痕迹保留，等待reviewer来解决冲突。具体就像这样。 到此为止，脚本应该是ok了，仓库地址 https://github.com/guguji5/sync-fork-repo。 应single-spa owner的要求，后续可能将此仓库transfer到single-spa的账号下 部署脚本虽然ok了，但是部署却着实让我费了一番功夫。所谓机器人，无非就是一个定时任务，也没有很强的时效性，每天同步一次就可以。 脚本中用到了环境变量，crontab的环境变量我相信谁用谁入坑，这里不展开，google可了解。 脚本中用了一些箭头函数，模板字符串等，对node版本有一定的要求。CentOs中如何升级node，当然是n模块啦。 脚本中使用了git rev-parse方法，git1和git2中语法不通，再屡次尝试升级git失败后，只好使用git1语法，git2兼容git1语法。 最后学了一招如何在同一组织下fork仓库。 结语虽然是一个很小的东西，但是做出来也是花了很多的时间，也学到了很多的东西，比如crontab定时任务，log4js日志管理后来很快就用到了，git的远程分支管理理解的更加深入。","categories":[],"tags":[{"name":"机器人","slug":"机器人","permalink":"guguji5.github.io/tags/机器人/"}]},{"title":"gitlab-CI和Docker前端自动化","slug":"gitlab-CI和Docker前端自动化","date":"2019-10-14T12:15:59.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"gitlab-CI和Docker前端自动化/","link":"","permalink":"guguji5.github.io/gitlab-CI和Docker前端自动化/","excerpt":"","text":"DevOps已经不是什么新概念了，现在前端开发人员多，分支多，测试环境多，前端自动化的重要性不（无)言（形）而（装）喻（比）。本博客的目的是实现在代码更新后，通过gitlab的webhook自动将部署文件打包成docker镜像。然后通过拿镜像名称去服务器上部署。这里我们分三步走，第一步配置Dockerfile先在本地测试docker build的流程；第二部注册gitlab-runner；第三部配置.gitlab-ci.yml监听代码更新后触发docker build流程并push到docker的hub。 docker 配置前端的部署环境很简单，无论你是react，vue还是Angular，部署的时候都是启动一个nginx，然后将build的静态文件放到nginx的共享目录就好了。这里我们不关心前端功能的具体打包过程，直接打包一个简单的html文件到镜像里就好。 1. 安装docker安装很简单，针对不同的系统提供了不同的方法，参照官方文档Install Docker安装即可。12345678910111213141516171819202122232425262728293031323334➜ ~ dockerUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default &quot;/Users/dida/.docker&quot;) -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default &quot;/Users/dida/.docker/ca.pem&quot;) --tlscert string Path to TLS certificate file (default &quot;/Users/dida/.docker/cert.pem&quot;) --tlskey string Path to TLS key file (default &quot;/Users/dida/.docker/key.pem&quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes ... 执行docker即为安装成功。 2. 镜像制作我们需要一个有nginx的镜像，可以nginx依赖一个操作系统。我们用ubuntu为base镜像，在里边安装nginx，然后再讲我们准备好的html（假设其为build后的前端工程）放到nginx的目录。docker build镜像可以用docker commit 也可以用Dockerfile，后者更为灵活，使用也更为广泛。 12345678FROM ubuntu:14.04RUN apt-get -yqq update &amp;&amp; apt-get -yqq install nginxRUN mkdir -p /var/www/html/websiteADD index.html /var/www/html/websiteRUN chmod -R 777 /var/www/html/websiteADD nginx/global.conf /etc/nginx/conf.d/ADD nginx/nginx.conf /etc/nginx/nginx.confEXPOSE 80 Dockerfile的内容包括以下几项： 使用ubuntu 14.04为基础镜像 更新并安装nginx 在容器中创建一个/var/www/html/website目录 将静态html文件拷贝到上述目录 将上述目录权限改为可读，可写，可执行 将准备好的nginx配置copy到容器中 暴露出来80端口 1234567891011# global.confserver &#123; listen 0.0.0.0:80; server_name _; root /var/www/html/website; index index.html index.htm; access_log /var/log/nginx/default_access.log; error_log /var/log/nginx/default_error.log;&#125; 12345678910111213141516171819202122# nginx.confuser www-data;worker_processes 4;pid /run/nginx.pid;daemon off;events &#123; &#125;http &#123; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; gzip on; gzip_disable &quot;msie6&quot;; include /etc/nginx/conf.d/*.conf;&#125; 具体代码可见 https://github.com/guguji5/demo/tree/master/try-ci 打包命令docker build -t [name]:[tag] .然后docker images查看本地镜像 2. 镜像上传\b制作好的镜像需要推到远端，就像我们的代码需要git push到仓库一样。首先你需要注册一个docker账号，docker login测试是否登录成功，成功后docker push [name]:[tag]推到远端 3. 测试镜像1docker run -d -p 8081:80 [name]:[tag] nginx 查看本地8081端口是否能访问到镜像中的80服务 gitlab-runner注册1.安装根据https://docs.gitlab.com/runner/install/ 选择对应平台安装根据https://docs.gitlab.com/runner/register/ 进行注册,Runner executor选择shell就好。注册成功后可以在Settings下边的CI/CD中的Runners看到刚注册的机器。 2.测试新建.gitlab-ci.yml并写入如下简单的命令测试job是否能执行成功 1234567891011121314151617# 执行job的阶段 按顺序串行执行stages: - uploadjob2: # 自定义名字 stage: upload # 指定这阶段操作的名称 only: # 指定那些分支会进入该处理流程 - master # 正式环境 variables: VERSION: &apos;damon&apos; # 除了后面会说到的私密变量 还可以在这里定义变量 before_script: script: - echo &quot;It is a job2,&quot; - echo $&#123;VERSION&#125; - your_name=&quot;qinjx&quot; - echo $your_name - echo $&#123;your_name&#125; 每当master有新的提交时，出触发上述脚本的运行。我们可以在CI/CD - Pipelines中看到对应的job。 自动化打包镜像我们的最终目的是每当代码更新后，自动打包成docker镜像，部署的每台服务器都用同一镜像部署就好。Build Once, Deploy Everywhere. 每当代码更新后gitlab 的hook会自动触发，我们只需要把第一步中的打包和上传的流程放到hook中即可。.gitlab-ci.yml如下：123456789101112131415161718192021stages: - build # 自定义阶段build的job流程job1: # 自定义名字 stage: build # 指定这阶段操作的名称 only: # 指定那些分支会进入该处理流程 - master # 正式环境 - pre # 预发环境 before_script: script: - docker login -u $USERNAME -p $PASSWORD - IMAGE_ID=`docker build . | tail -n 1 | awk -F &quot;Successfully built &quot; &apos;&#123;print $2&#125;&apos; | sed &apos;s/^ *\\| *$//g&apos;` - echo &quot;IMAGE_ID=$IMAGE_ID&quot; - DATE=`date +%Y%m%d`; - docker tag $IMAGE_ID guguji/forth:$DATE.$CI_JOB_ID; - docker push guguji/forth:$DATE.$CI_JOB_ID; - docker rmi guguji/forth:$DATE.$CI_JOB_ID; - echo &quot;--------------------------------------------------------------------------------&quot;; - echo &quot;guguji/forth:$DATE.$CI_JOB_ID&quot;; 其中的$USERNAME $PASSWORD是Setting - CI/CD - Variables 中存入的变量。其含义依次是： 登录docker 执行docker build 并将输出的将镜像ID赋值给IMAGE_ID 给上述镜像打上标签 上传到docker hub 删除本地镜像 输出镜像名称 结果如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Running with gitlab-runner 12.3.0 (a8a019e0) on damon test xXUC7Le6Using Shell executor...Running on 10-254-203-137...Fetching changes...Reinitialized existing Git repository in /home/gitlab-runner/builds/xXUC7Le6/0/guguji5/try-ci/.git/From https://gitlab.com/guguji5/try-ci * [new ref] refs/pipelines/89119102 -&gt; refs/pipelines/89119102 7aeff9e..6d585aa master -&gt; origin/masterChecking out 6d585aa7 as master...Skipping Git submodules setup$ docker login -u $USERNAME -p $PASSWORDWARNING! Using --password via the CLI is insecure. Use --password-stdin.WARNING! Your password will be stored unencrypted in /home/gitlab-runner/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded$ IMAGE_ID=`docker build . | tail -n 1 | awk -F &quot;Successfully built &quot; &apos;&#123;print $2&#125;&apos; | sed &apos;s/^ *\\| *$//g&apos;`$ echo &quot;IMAGE_ID=$IMAGE_ID&quot;IMAGE_ID=41555aab3b76$ DATE=`date +%Y%m%d`;$ docker tag $IMAGE_ID guguji/forth:$DATE.$CI_JOB_ID;$ docker push guguji/forth:$DATE.$CI_JOB_ID;The push refers to repository [docker.io/guguji/forth]82ce84f6435c: Preparing8f360e1cf4bb: Preparing8f360e1cf4bb: Pushed29c9093a1ab9: Pushed66285ac4bf24: Layer already exists48334332ed8d: Layer already exists82ce84f6435c: Pushedb057ab380990: Layer already existsbc89fbcf9125: Pushed46c1a22ffea5: Layer already existsb17e63608209: Layer already exists20191016.322211021: digest: sha256:971e8c83827b10e1ffb9d109f7b2507e26622b56113f5ee183b92bdc8e0acd8a size: 2401$ docker rmi guguji/forth:$DATE.$CI_JOB_ID;Untagged: guguji/forth:20191016.322211021Untagged: guguji/forth@sha256:971e8c83827b10e1ffb9d109f7b2507e26622b56113f5ee183b92bdc8e0acd8aDeleted: sha256:41555aab3b76a88fbde71a02afd7c400973d8ec9f1ab7ce533d4d7cc6dfdb17eDeleted: sha256:854ac28d0ceabc1b910aa58e96d1fabe577a63a60c3459ca7ee6152f00630cc1$ echo &quot;--------------------------------------------------------------------------------&quot;;--------------------------------------------------------------------------------$ echo &quot;guguji/forth:$DATE.$CI_JOB_ID&quot;;guguji/forth:20191016.322211021Job succeeded 如果有如下报错1Got permission denied while trying to connect to the Docker daemon socket 原因是gitlab-runner执行时 是以 gitlab-runner用户来执行的 该用户不属于docker group，需将该用户加入该组。首先查询 是否有该用户 cut -d : -f 1 /etc/passwd然后查询 是否存在docker组sudo groupadd docker然后执行 将gitlab-runner加入docker组 sudo gpasswd -a gitlab-runner docker 我们想要的效果是在服务器上拉取我们刚build并上传的镜像，并run 起来就好。我们可以在本地用如下命令测试刚打包的镜像 12docker pull guguji/forth:20191016.322211021docker run -d -p 8080:80 guguji/forth:20191016.322211021 nginx 效果如下1234567891011121314151617➜ ~ docker pull guguji/forth:20191016.32221102120191016.322211021: Pulling from guguji/fortha7344f52cb74: Already exists515c9bb51536: Already existse1eabe0537eb: Already exists4701f1215c13: Already existsb9999057545e: Pull complete57c313e6fd56: Pull complete76ac29208590: Pull completeebec49c77172: Pull completec514c1fe8afa: Pull completede4ad1f5b5dc: Pull completeDigest: sha256:971e8c83827b10e1ffb9d109f7b2507e26622b56113f5ee183b92bdc8e0acd8aStatus: Downloaded newer image for guguji/forth:20191016.322211021➜ ~ docker run -d -p 8080:80 guguji/forth:20191016.322211021 nginx330efb99cafab59b46ddaf61a62221bf94722e9c76be59523b538cb3a49bd651➜ ~","categories":[],"tags":[]},{"title":"一次项目合并经历","slug":"一次项目合并经历","date":"2019-09-29T07:01:27.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"一次项目合并经历/","link":"","permalink":"guguji5.github.io/一次项目合并经历/","excerpt":"","text":"我所在的组有很多项目，其中一个是对外供用户使用的以下简称项目A，还有一个是对内进行资源管理提高效率的以下简称项目B。项目Acss\b解析用postcss，ui组件用element ui，项目B css解析用less，ui组件使用内部开发的一套ui库。 接到一个需求：同事辛辛苦苦做的在A项目中的某个功能（六七个页面）能不能一股脑的嵌入B项目呢？最好不用开发，你们前端不都是Vue 组件么？复用一下噻？ 刚接到需求的时候大脑里跑过了千万匹🐴，但是遇到困难不能躲啊。冷静思考一下，先iframe被排除了，因为iframe只能整体的嵌入，而我们想要的可能只是页面\b中的一部分。第一次尝试把A整个项目手动copy到B项目中，通过相对路径来引用。最开始的报错是postcss解析报错，费了半天劲解决后就是，js重名，css覆盖，字体冲突。总结一下遇到的问题list 如下： postcss loader配置失败 嵌入A后A全局样式污染B全局样式 B中嵌入的ui库和A的element组件冲突 (e.g. v-loading) 登录状态如何保持 webpack alias重名，都叫utils，都叫components A引入B后样式丢失 自定义的组件覆盖了el样式 B中的字体库和element中的冲突了（content: “\\e69a”显示了不同的图标） build failed 解决方法 vue-loader的设置不熟悉，按照官网的配置不生效。原来vue文件在解析的时候会根据language解析成不同后缀名的文件。只需要 { test: /\\.postcss$/, use : cssLoaders(&#39;postcss&#39;) } 即可。 如我们所知A中有很多全局样式，引入部分页面缺了这部分全局样式又没法正常渲染，借助postcss-plugin-namespace可以给postcss的文件加一个前缀，确保不因小失大，污染整个B。 因为element中的组件比内部开发的组件库健壮的多，大部分都是element覆盖之。 A中页面要想正常工作首先是以登录为前提的。还有一条路就是在api上带上某个特定标识，由此也引发了一个小问题。需要改变location search,url会replace，刷新页面。还可以优化。 A中的webpack alias我不敢改，我只能委曲求全改B中的，改成不重名的。 A依赖了好多全局样式，一个一个引入。有些B中的样式跟A中的确实是冲突，确实影响到了。只好自己调整调整，但是需要调整的量很小，就两三处。 有同事把element的源码拿到项目中使用。而且还稍加改动了css。删掉就好了。 要想让A中页面正常渲染图标也必不可少，但是element中的字体是font-family: element-icons!important;非常强暴的把所有的图标都用自己的这套字体库。没办法，只好也把我们自己\b的字体库也加上了!important。 最终以submodule的方式引入A。A中的.postcssrc.js 和B全局的冲突了。按照官方的options配置，但是还是没成功，只好在gitlab hook中删掉submodule中的.postcssrc.js。这样不好，但是能work。（https://github.com/postcss/postcss/issues/1295） 思考最终不是太完美的上线了，还有一些地方可以优化。虽然嵌入的Acss样式不会影响B全局，但是B全局的样式还是会影响嵌入的A样式。js方法最好能互不影响。 微前端的材料看了不少，但还是没找到小成本能实现的方式，可能需要在规划两个或多个项目时就已经想好了实现的方式，有主项目，有include项目等等。对于两个已经成熟的项目如何互相include，甚至不同框架的项目怎么融合，啊~啊~啊~，这个题超纲了。 参考资料 https://tech.meituan.com/2018/09/06/fe-tiny-spa.html https://forum.vuejs.org/t/advice-to-organize-multiple-vue-projects/15078","categories":[],"tags":[]},{"title":"滴滴云控制台Selenium自动化测试初探","slug":"滴滴云控制台Selenium自动化测试初探","date":"2019-02-13T06:23:21.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"滴滴云控制台Selenium自动化测试初探/","link":"","permalink":"guguji5.github.io/滴滴云控制台Selenium自动化测试初探/","excerpt":"","text":"Selenium是一系列基于Web的自动化工具，提供一套测试函数，用于支持Web自动化测试。函数非常灵活，能够完成界面元素定位、窗口跳转、结果比较。具有如下特点： 多浏览器支持。如IE、Firefox、Safari、Chrome、Android手机浏览器等。 支持多种语言。如Java、C#、Python、Ruby、PHP等。 支持多种操作系统。如Windows、Linux、IOS、Android等。 开源免费。官网：http://www.seleniumhg.org/ Selenium组成部分一、Selenium IDE该工具是一个用于构建脚本的初级工具，其实是FireFox的一个插件，拥有一个易于使用的界面。它拥有记录功能，能够记录用户执行的操作，并可以导出为可重复使用的脚本。如果没有编程经验，可以通过Selenium IDE来快速熟悉Selenium的命令。较少使用。 二、Selenium RCSelenium RC是selenium家族核心部分。Selenium RC支持多种不同的语言编写自动化测试脚本，通过SeleniumRC的服务器作为代理服务器去访问应用，从而达到测试的目的。 三、Selenium WebDriver当Selenium2.x提出了WebDriver的概念之后，它提供了完全另外的一种方式与浏览器交互。那就是利用浏览器原生的API，封装成一套更加面向对象的SeleniumWebDriver API，直接操作浏览器页面里的元素，甚至操作浏览器本身（截屏，窗口大小，启动，关闭，安装插件，配置证书之类的）。由于使用的是浏览器原生的API，速度大大提高，而且调用的稳定性交给了浏览器厂商本身，显然是更加科学。然而带来的一些副作用就是，不同的浏览器厂商，对Web元素的操作和呈现多少会有一些差异，这就直接导致了Selenium WebDriver要分浏览器厂商不同，而提供不同的实现。例如Firefox就有专门的FirefoxDriver，Chrome就有专门的ChromeDriver等等。（甚至包括了AndroidDriver和iOS WebDriver） 四、Selenium GridSelenium Grid通过在许多服务器上同时运行测试，将Selenium Remote Control带到另一个层次，从而减少了测试多个浏览器或操作系统所需的时间。 这里借助Selenium WebDriver，以滴滴云控制台的默认选中为例\b展示Selenium如何解放测试人员的双手。 滴滴云控制台的\bDC2创建页承载着复杂的业务逻辑，众多页面都需要跳转到此，并\b需要根据URL上的参数\b而对DC2的配置做默认选中。当多人开发对\b业务逻辑耦合时，众多逻辑均会对默认选中的结果造成影响，难以避免导致BUG的产生。在手动测试的\b情况下，需要回归测试整个页面的所有功能点，而用Selenium如何如何保证页面的稳定呢？ Selenium安装Selenium支持多种语言，python\b\b最受欢迎，\b安装也比较简单。1pip install selenium 然后需要根据链接下载chromedriver 到/usr/local/bin。 执行以下代码检测你的环境已经安装完毕12345678910# coding = utf-8from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;)browser.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)browser.find_element_by_id(&quot;su&quot;).click()time.sleep(3)browser.quit() 如果程序能正常打开你的\bChrome浏览器，输入selenium并搜索，则说明Selenium安装成功。 Selenium定位页面元素webdriver提供了一系列的对象定位方法，常用的有id,name,class name,link text,partial link text,tag name,xpath,css selector，针对百度的网页可以有一下多种方法定位页面元素。 1234567891011121314151617181920212223242526272829303132333435#coding=utf-8from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get(&quot;http://www.baidu.com&quot;)time.sleep(2)#########百度输入框的定位方式###########通过id方式定位browser.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)#通过name方式定位browser.find_element_by_name(&quot;wd&quot;).send_keys(&quot;selenium&quot;)#通过tag name方式定位browser.find_element_by_tag_name(&quot;input&quot;).send_keys(&quot;selenium&quot;)#通过class name 方式定位browser.find_element_by_class_name(&quot;s_ipt&quot;).send_keys(&quot;selenium&quot;)#通过CSS方式定位browser.find_element_by_css_selector(&quot;#kw&quot;).send_keys(&quot;selenium&quot;)#通过xpath方式定位browser.find_element_by_xpath(&quot;//input[@id=&apos;kw&apos;]&quot;).send_keys(&quot;selenium&quot;)############################################browser.find_element_by_id(&quot;su&quot;).click()time.sleep(3)browser.quit() 测试登录\b因为滴滴云控制台部分页面需登录后方可打开，所以测试的第一步打开首页，\b填入用户名密码。 1234567891011121314151617#coding=utf-8from selenium import webdriverimport timedriver = webdriver.Chrome()driver.get(&quot;http://app.didiyun.com&quot;)driver.find_element_by_css_selector(&apos;input[type=&quot;text&quot;]&apos;).send_keys(&quot;189****3932&quot;)driver.find_element_by_css_selector(&apos;input[type=&quot;password&quot;]&apos;).send_keys(&quot;3e****FV&quot;)time.sleep(2)subbutton=driver.find_element_by_css_selector(&apos;button[type=&quot;submit&quot;]&apos;)subbutton.click()time.sleep(3) 检查程序可以打开滴滴云控制台首页，并成功登录dashboard页，则登录验证成功。 测试默认项选中本次自动化测试的目的为检测从官网跳转到控制台时，进入https://app.didiyun.com/#/dc2/add?srvType=ebs&amp;systemDiskType=HE&amp;zoneId=gz01 页，\b能否默认选中广州一区，标准云服务器，\b系统盘为高效云盘。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding=utf-8from selenium import webdriverimport timedriver = webdriver.Chrome()driver.get(&quot;http://app.didiyun.com&quot;)driver.find_element_by_css_selector(&apos;input[type=&quot;text&quot;]&apos;).send_keys(&quot;18903393932&quot;)driver.find_element_by_css_selector(&apos;input[type=&quot;password&quot;]&apos;).send_keys(&quot;3edc$RFV%TGB&quot;)time.sleep(2)#测试的最终结果TEST_PASS = Truesubbutton=driver.find_element_by_css_selector(&apos;button[type=&quot;submit&quot;]&apos;)subbutton.click()time.sleep(3)if (driver.current_url == &apos;https://app.didiyun.com/#/&apos;): print &apos;Success our dashboard login&apos;print &quot;Opening our target page&quot;driver.get(&apos;https://app.didiyun.com/#/dc2/add?srvType=ebs&amp;systemDiskType=HE&amp;zoneId=gz01&apos;)#浏览器打开需要时间time.sleep(3)if (driver.current_url == &apos;https://app.didiyun.com/#/dc2/add?srvType=ebs&amp;systemDiskType=HE&amp;zoneId=gz01&apos;): print &apos;Opened the dc2 add page&apos;#################################################regionName = driver.find_element_by_css_selector(&apos;div.region-select3-item.active .region-head span&apos;).textzoneName = driver.find_element_by_css_selector(&apos;div.region-select3-item.active .zone-item.active span&apos;).textif(regionName != u&apos;广州&apos;): TEST_PASS = False print u&quot;期望区域是广州，但实际选中是%s&quot; %(regionName)else: if(zoneName != &apos;1&apos;): TEST_PASS = False print u&quot;期望1区，但实际选中是%s区&quot; %(zoneName)#################################################serverType = driver.find_elements_by_xpath(&apos;//*[@id=&quot;app&quot;]/div[2]/div/form/div[3]/div[1]/div/div[1]/div/div[2]/div/span[1]&apos;)[0].textif(serverType != u&apos;标准云服务器&apos;): TEST_PASS = False print u&quot;期望服务器类型是标准云服务器，但实际选中是%s&quot; %(serverType)##################################################serverVerion = driver.find_elements_by_xpath(&apos;//*[@id=&quot;app&quot;]/div[2]/div/form/div[3]/div[2]/div[1]/div/label[1]/span/span&apos;)[0].textif(serverVerion != u&apos;通用型&apos;): TEST_PASS = False print u&quot;期望服务器类型是通用型，但实际选中是%s&quot; %(serverVerion)#################################################diskType = driver.find_element_by_css_selector(&apos;div.selector-wrapper input&apos;).get_attribute(&apos;value&apos;)if(diskType != u&apos;高效云盘&apos;): TEST_PASS = False print u&quot;期望的系统盘类型是高效云盘，但实际选中是%s&quot; %(diskType)if(TEST_PASS): print &apos;SUCCESS 从官网跳到控制台dc2创建页，选中了对应的配置&apos;else: print &apos;FAIL 从官网跳到控制台dc2创建页，未选中了对应的配置&apos;time.sleep(3)driver.close() 如果有如下输出，则测试失败，需要我们手动进入对应页面查看默认选中项的情况。 123456(venv) ➜ ~ python test.pySuccess our dashboard loginOpening our target page期望的系统盘类型是高效云盘，但实际选中是普通云盘FAIL 从官网跳到控制台dc2创建页，未选中了对应的配置(venv) ➜ ~ 如果有如下输出，则通过测试。123456(venv) ➜ ~ python test.pySuccess our dashboard loginOpening our target pageOpened the dc2 add pageSUCCESS 从官网跳到控制台dc2创建页，选中了对应的配置(venv) ➜ ~ 后记我们知道，selenium是一个很优秀的web框架，提供了很丰富的API，使用它结合进行做web的自动化测试真的很完美，但是在实际的情况中，理想与现实总是存在那么一点距离，这点距离主要是难维护，难维护的最核心是页面元素经常改变，测试过程中数据很多，不知道怎么进行维护，页面元素确实经常改变，很难改变，另外一个就是数据问题，比如我们验证N个表单在不同输入情况下的提示信息，会有不同的提示信息，都得需要验证。 本文只是一个菜鸡前端为减少重复劳动而对自动化测试所做的一个探索，专业的自动化测试肯定会封装的更加\b易用，可读，可维护。断言，日志都会用更加专业的框架。\b 期待自动化测试可以为滴滴云的稳定性\b出一份力。 参考链接： Selenium官网：https://www.seleniumhq.org","categories":[],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"guguji5.github.io/tags/自动化测试/"}]},{"title":"SVG Sprite优化滴滴云项目中的图标","slug":"SVG-Sprite优化滴滴云项目中的图标","date":"2018-11-22T13:54:26.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"SVG-Sprite优化滴滴云项目中的图标/","link":"","permalink":"guguji5.github.io/SVG-Sprite优化滴滴云项目中的图标/","excerpt":"","text":"背景介绍滴滴云用户系统随着\b模块，功能，页面的增多，小图标也越来越多，随着开发人员的不断加入\b以及图片需求的\b不断更新，项目中图片的引用方法也变得多种多样。本次调研旨在整理项目中的图标，网站加载\b速率，统一开发人员\b引用图片的用法。 项目\b现状项目中图片的使用方式有以下三种 iconfont，单色小图片。 inline直接引用图片。 inline直接引用，图片小于2k，\b转为base64。 第2项中大图片直接引用无可否非，\b但目前项目中有70-80多个4k-8k的小图片也是直接引用到项目里，这次调研主要针对小图片进行合并，减少请求数，优化网站的响应速度。 CSS \bSPRITECSS Sprite是传统的优化图片的方法，基本原理也很简单，把小图标按照\b一定顺序合并在一个大图上，使用时需按background-image方式引入，辅以background-position来控制需要显示图片的位置。 \bwebpack-spritesmith组件可以实现合并小图片，并生成相对于的css样式，在原来使用的标签上\b添加对应的class类名即可。但是此方法针对项目中通过&lt;img src=&quot;imgages/demo.png /&gt;标签内联引用图片的方式改动较大，需将img标签转换为background显示，\b\b可读性减弱，改动\beffort较大，样式\b出错的\b机会及测试的成本都很大，顾放弃此方法。 SVG \bSPRITESVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 SVG可以直接\b放在HTML，CSS里\b使用。SVG Sprite是依赖其symbol标签和use标签实现其合并的效果。合并完以后的\bsvg大概如下图1234567891011&lt;svg&gt; &lt;symbol id=&quot;shape&quot;&gt; &lt;!-- 第1个图标路径形状之类代码 --&gt; &lt;/symbol&gt; &lt;symbol&gt; &lt;!-- 第2个图标路径形状之类代码 --&gt; &lt;/symbol&gt; &lt;symbol&gt; &lt;!-- 第3个图标路径形状之类代码 --&gt; &lt;/symbol&gt;&lt;/svg&gt; use的语法如下123&lt;svg&gt; &lt;use xlink:href=&quot;#shape&quot; x=&quot;200&quot; y=&quot;50&quot; /&gt;&lt;/svg&gt; 我们\b期望的效果是把所有svg都通过symbol合并到一个大的svg sprite，而手动维护显然是不现实的，所以我们需要svg-sprite-loader，他可以根据config来自动合并所有的svg，形成\b一个大的svg sprite。需在webpack中添加的配置如下：1234567891011121314&#123; test: /\\.svg$/, loader: &apos;svg-sprite-loader&apos;, include: [resolve(&apos;src/assets/images/svg&apos;)], //只合并固定目录 options: &#123; extract: true, // 将合并后的svg提取为一个单独文件，默认false，会将svg\b解析后以内联方式打包到模板里 spriteFilename: utils.assetsPath(&apos;img/sprite.svg&apos;), symbolId: &apos;icon-[name]&apos;, //symbol id的rename规则 &#125;&#125;,// 主动调用webpack 方法，\b循环遍历\bsvg目标文件夹下所有svg格式文件。const req = require.context(&apos;assets/images/svg&apos;, false, /\\.svg$/)const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)requireAll(req) 至此，项目中就可以以&lt;svg&gt;&lt;use xlink:href=&quot;#shape&quot;/&gt;&lt;/svg&gt;\b方式来用svg展示icon。进一步可以封装为vue组件以方便使用。1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;svg class=&quot;svg-icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use :xlink:href=&quot;iconName&quot;&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;icon-svg&apos;, props: &#123; iconClass: &#123; type: String, required: true &#125; &#125;, computed: &#123; iconName () &#123; return `sprite.svg#icon-$&#123;this.iconClass&#125;` &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.svg-icon &#123; width: 1em; //能继承font-size的大小 height: 1em; vertical-align: -0.15em; fill: currentColor; //可以接受外部color，改变svg内部currentColor的路径 overflow: hidden;&#125;&lt;/style&gt; 组件可以实现和iconfont一样的通过font-size，color修改图标的大小和颜色，使用方法也更加友好，只需&lt;icon-svg icon-class=&quot;wechat-for-signin&quot; /&gt;,在icon-class传入svg名字即可。在页面中的node节点渲染如图： svg vs iconfont icon-svg iconfont 多种色彩 单一色彩 真正的矢量 字体文件 css控制大小，颜色，甚至局部颜色 css控制大小，颜色 webpack实现 需要借助外部工具 IE9+ IE6 SVG待解决问题通过symbol+use的方式引入svg，当&lt;use xlink:href=&quot;&quot;&gt;引用的是外部资源时在vue的template里v-if渲染会有问题。\b尤大大解释说这是chrome的bug。https://github.com/vuejs/vue/issues/2661https://github.com/vuejs/vue/issues/2782 issue提出\b已经两年了，\b有没有官方的解决方案还需继续调研。目前的workaround有一下三种： 将v-if改为v-show 不提取sprint.svg,内联引用\b， 将sprint.svg通过webpack达成chunk包,通过js引用sprint.svg。 总结项目中4k-8k的小图片没有以iconfont方式引入的方式，原因不管是\b“多色”，“图片格式限制”。引入icon-svg后，随着设计师更新icon，我们希望尽量将图切成svg，一并合到sprite.svg中，svg文件经过gzip的压缩，会达到减少请求，增加传输的效率的目的。 参考链接 https://css-tricks.com/svg-symbol-good-choice-icons/https://github.com/PanJiaChen/vue-element-admin","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"guguji5.github.io/tags/优化/"}]},{"title":"Hexo + Github搭建静态博客(二)","slug":"Hexo-Github搭建静态博客-二","date":"2018-11-11T08:43:29.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"Hexo-Github搭建静态博客-二/","link":"","permalink":"guguji5.github.io/Hexo-Github搭建静态博客-二/","excerpt":"","text":"快速介绍本文是接Hexo + Github搭建静态博客(一)，Hexo环境的搭建，依赖的下载请根据上文自行配置。本文主要介绍Hexo的归档，标签，分类，以及依靠插件支持的评论，站内搜索，字数统计等功能。 归档，分类，标签三者\b是众多博客模板的必要元素，而在文档中却没有详细的解释，匆匆一笔带过。笔者阅历浅薄，结合自己的理解，强行解释\b一波，通过对比将意思表达的更清楚。 归档（archives）是按照一定的周期对博客进行分类，大多数是按年，月等。 分类\b（categories）和 标签（tags）都是用来描述博客的内容，\b但却又不尽相同。分类 定义博客的常规主题，而标签会深入反应内容。分类会\b构成博客的大纲，反应博客的基本结构，而标签会更具体一些。（其实还是\b会让人confuse）下边我\b希望通过一个小故事解释清\b“分类”和“标签”的不同。 假如我们运营着一个关于电子产品（3C）的博客，有\b众多的博文，可能会有以下的分类 笔记本 手机 存储设备 数码相机 当新出iphone的时候，我们可能会写一个\b新产品开箱博客，他分类肯定是”手机“，而标签会是”iphone“。 创建对应的页面也很简单，只需一行命令。 123hexo new page &quot;archives&quot;hexo new page &quot;tags&quot;hexo new page &quot;categories&quot; 站内搜索方式有以下三种，insight、swiftype、baidu。 insight只需安装hexo-generator-json-content组件即可。swiftype需要去其官网注册key。baidu搜索的话需要禁用其他两种。 三种都很简单，这里展示第一种的效果图。 评论\b评论是博客必不可少的一项功能。而Hexo作为一个静态博客，没有WordPress那样\b的server和数据库，评论的功能可想而知肯定是用的第三方的评论系统。大浪淘沙，对比各色的需求，接下来我们\bXXX。 来必力 : 504报错，跨域 Hypercomments: 付费 畅言 : 畅言 Valine : sound good 多说 : 关闭 网易云跟帖 : 关闭 disqus : 科学上网 gitalk : 需要Github账号 搜狐畅言 : 备案 这个topic展开的话会很冗长，搜索引擎上也有很多这类的文章。我最后选择了gittalk，\b简单大方，技术类的文章，\bGithub不是门槛。 字数统计，阅读时间统计这一部分比较简单，只需要安装hexo-wordcount插件，\b传入博客的内容即可计算得出。先安装插件：1npm i --save hexo-wordcount 在主题模板文件中即可使用wordcount方法计算字数统计和阅读时长。12345678&lt;% if(theme.postCount.enable)&#123; %&gt; &lt;% if(theme.postCount.wordcount)&#123; %&gt; &lt;span class=&quot;post-wordcount hidden-xs&quot; itemprop=&quot;wordCount&quot;&gt;&lt;%= __(&apos;article.wordcount&apos;) %&gt;: &lt;%= wordcount(post.content) %&gt;(&lt;%= __(&apos;unit.word&apos;) %&gt;)&lt;/span&gt; &lt;% &#125; %&gt; &lt;% if(theme.postCount.min2read)&#123; %&gt; &lt;span class=&quot;post-readcount hidden-xs&quot; itemprop=&quot;timeRequired&quot;&gt;&lt;%= __(&apos;article.readcount&apos;) %&gt;: &lt;%= min2read(post.content) %&gt;(&lt;%= __(&apos;unit.time&apos;) %&gt;)&lt;/span&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 如何在博客展示自己github托管的项目作为一个程序员，GitHub开源项目是程序员展示编程技术和工作阅历，释放程序员个人魅力的宽广舞台。所以，很有必要在博客的核心页面展示自己GitHub的repository。Hexo可以在主题内通过ejs或swig模板引擎来构建页面，GitHub提供开源api支持获取repo列表。所以我们可以通过调用引入JavaScript请求api。展示效果如下 问题出在Github的未授权状态的api每小时只可以请求60次，而超出次数就会403。而授权的api每小时可以访问50000次。所以需要去https://developer.github.com/v3/auth/#basic-authentication申请授权，我们搭建的Hexo静态博客，没有Server，所以oauth2的方式\b不可取，这里我用的access_token来对api授权，Github出于安全的考虑，不允许我们把access_token上传到Github仓库，所以我们需要借助你擅长的加密方式，对access_token加密，运行时解密。伪代码如下：1234var key = &apos;U2FsdGVkX1+VWdiIkoA3PCbz9KKGlKilMs6UztGd2VQuYuSAoZLyCi8fM2qxUbviYt35kf/tpFvEqNmtY3WppQ=&apos;var access_token = CryptoJS.AES.decrypt(key, &apos;guguji5&apos;).toString(CryptoJS.enc.Utf8);$.get(&quot;https://api.github.com/users/&lt;%=theme.github.username%&gt;/repos?access_token=&quot;+access_token, function(result) &#123;&#125;) 参考链接 https://developer.github.com/v3/auth/#basic-authentication https://developer.github.com/v3/#rate-limiting https://amylynnandrews.com/categories-vs-tags/","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"guguji5.github.io/tags/Hexo/"}]},{"title":"bakery性能优化","slug":"bakery性能优化","date":"2018-11-11T03:15:17.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"bakery性能优化/","link":"","permalink":"guguji5.github.io/bakery性能优化/","excerpt":"","text":"香满苑蛋糕屋的微信站bakery运行在了亚马逊云（1G内存+1核+8G硬盘），俄亥俄洲的主机上，平均有300ms的延迟，因为是试运行所以暂时也没有换的打算。在“时间就是金钱的”21世纪，性能优化就显得更为重要，主页load时间过长会让用户失去耐心，前端后台以及mongodb数据库的优化变得不可或缺。 这里分前端、后台和数据库三部分来记录一下我说做的工作。 web前端的优化 代码的合并、压缩、增加md5的版本都是webpack做的，以及把文件打包成几个bundle文件。减少请求次数。 小图标根据需要缩小，不使用大图。10241024的图标直减为2020。 小图标的合并，css雪碧图的使用，减少请求次数。 大量图片（包括雪碧图）从服务器拉取比较慢，上传到新浪微博的图床。 code split。 webpack热重载慢，webpack2升级到webpack3速度提高10倍；开发过程中就用普通路由，懒加载路由在webpack中会使cache失效。 从webpack的analysis中可以看出，资源文件打包成两个包。vendor较大，230k左右，app很小几十K。手机端浏览器大部分会同时拉取4个资源，根据木桶原理，最终完毕时间肯定由最慢的一个资源决定。所以将mint-ui的内容从vendor中转移到app中，两个大小都在150k左右。 node后台的优化 设置一个设置favicon.ico，不然每次都返回404。 后台开启gzip超级有效，大概压缩率打到75%，从上边code split中可以看出159k的可以直接压缩成54k传过来。（有关gzip还专门翻译了一篇文章：how to optimieze your site with gzip） 占据渲染时间大半壁江山的都是图片，图片缓存很重要，从新浪图床上下载下来的，新浪服务器缓存的很好。少量从我服务器上的图通过IF-Modified-since/last-modified last-modified和if-none-match/etags来设置好缓存。未过期的值或者未变化的值浏览器端直接读取缓存。 数据库和微信（菜鸟备忘） 指定需要返回的键 db.users.find({},{“username”:1,”email”:1}) 比db.users.find() 然后再解析数据肯定是要快。 mongodb启动时候要加用户名密码dbpath -auth，裸奔很危险。 用户表（user ）的收货人数组的id通过生成随机数的方式来使其保证唯一，可以换成$ne或者$addToSet来将数组作为数据集使用，保证数组内的元素不会重复。 评论放在产品详情（productDetail）表，然后把name和头像url都存进去。db.blog.update({“title”:”a blog post”},{$push:{“commit”:{“name”:”jone”,”headimgurl”:”www.example.com/1.jpg&quot;,“content”:”nice post”}}}) 微信端jsapi_ticket,access_token等数据都有每日最大请求次数和过期时间，需要缓存在数据库，通过TTL的设置来实现过期expires。","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"guguji5.github.io/tags/优化/"}]},{"title":"如何使用GZIP来优化你的网站","slug":"如何使用GZIP来优化你的网站","date":"2018-11-09T05:22:55.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"如何使用GZIP来优化你的网站/","link":"","permalink":"guguji5.github.io/如何使用GZIP来优化你的网站/","excerpt":"","text":"如果你想节省带宽提高网站速度，压缩是一种简单有效的方法。当我打算提高JavaScript的传输速率来开启GZIP压缩的时候，我犹豫了因为有旧版本浏览器的存在（IE6）。 然而在二十一世纪，我们大部分的流量来自于现代浏览器，坦白的讲，我们大部分的用户都是很懂技术的。我们不想让任何一个人在访问我们网站的时候卡顿，哪怕是他在用IE4.0和Wdinows95.谷歌和雅虎都开启了gzip压缩。一个现代的浏览器要想不仅要享受到现代网络信息还要享受到现代互联网的速度，就必须开启gzip压缩。以下是如何设置。 等等，为什么我们要开启gzip压缩在此之前，我有必要解释一下什么编码。当你在互联网上想请求一个文件时,比如http://www.yahoo.com/index.html，你的浏览器会和服务器有一个会话，大概如下如所示。 浏览器：嘿，给我来一个 index.html文件 服务器：好的，让我去找找它是不是在~ 服务器：找到它了，我会返回一个成功的状态码（200 ok），我正在发送文件…… 浏览器：100kb？ 我滴天……等啊……等啊，好的，下载下来了 当然，实际的请求头和协议会更加正规一点。 但是，它生效了，我拿到了index.html文件。 那现在问题在哪呢？好吧，这系统是正常的，但是太低效了，坦白讲100kb是一大段的文字，HTML是冗余的，每一个,,都有一个几乎相同的闭合标签。虽然通篇文字都有重复，但是只要你砍掉任何的内容，html（以及它的一奶同胞xml）都不会正常显示。 当文件太大的时候有什么好办法呢，就是gzip压缩它。 如果我们传输一个替代原始大文件的zip的压缩文件给浏览器，就会节省带宽和下载时间。当浏览器可以下载zip文件，解压，并且渲染给用户。下载很快，页面加载也很快，用户心情就会very good。这个浏览器–服务器的会话大概是酱紫的： 浏览器：嘿，给我来一个index.html，如果要有，给我来一个压缩版的可以吗 服务器：容我找找……好，满足你，如果找到了给你压缩以下，gzip格式的哦 服务器：yep，找到了，正在压缩，马上传给你。 浏览器：太棒了，只有10kb，我来解压，并且渲染给用户。 情况很简单：文件越小，下载更快，用户感受更好。 不相信我？雅虎主页的html部分通过压缩从101kb直接压到了15kb： 残（淡）酷（定）的现实变化的部分在于浏览器和服务器，它成功的发送过去一个压缩文件。对于gzip压缩的要点有两点： 浏览器发送一个请求头，告诉服务器接受压缩版本的文件（gzip和deflate是两种压缩算法）Accept-Encoding:gzip,deflate 如果文件压缩了,服务器返回一个头信息:Content-Encoding:gzip 如果服务器没有返回Content-Encoding的头信息，意味着这文件是没压缩的（浏览器可以直接解析的）。请求头Accept-Encoding只是浏览器的一个请求，而不是命令。如果服务器不返回压缩文件，浏览器就不得不处理那庞大的源文件。 服务器设置“好消息”是我们没办法控制浏览器。他发“Accept-encoding: gzip, deflat”或者不发，请求头就在那里，不增不减。 我们需要做的只是给服务器配置，让它返回压缩版本。如果浏览器控制，我们可以为每一个人节省带宽。 对于IIS服务器，启动压缩在“设置”里。 如果你像我一样用nodejs来搭建服务器，那你中奖了，nodejs开启gzip非常的简单，只需增加两行代码搞定。 123456const express = require(&apos;express&apos;);const app = express();//express框架，前边肯定都是必要的，也就是只需安装compression组件，然后添加一下两句代码就好const compression = require(&apos;compression&apos;);app.use(compression()); 对于Apache服务器，我们可以启动压缩输出也很简单直接。在你的.htaccess文件里增加如下代码： 123456789101112131415# compress text, html, javascript, css, xml:AddOutputFilterByType DEFLATE text/plainAddOutputFilterByType DEFLATE text/htmlAddOutputFilterByType DEFLATE text/xmlAddOutputFilterByType DEFLATE text/cssAddOutputFilterByType DEFLATE application/xmlAddOutputFilterByType DEFLATE application/xhtml+xmlAddOutputFilterByType DEFLATE application/rss+xmlAddOutputFilterByType DEFLATE application/javascriptAddOutputFilterByType DEFLATE application/x-javascript# Or, compress certain file types by extension:&lt;files *.html&gt;SetOutputFilter DEFLATE&lt;/files&gt; Apache服务器有两个压缩选择： mod_deflate 更简单设置更加标准。 mod_gzip 看起来更加强大，可以预预缩文件。 Deflate更快，所以我用的它；当然如果想更爽，用mod_gzip。无论你选那种，Apache会检查浏览器是否发送“Accept-encoding”请求头来判断是返回压缩文件还是源文件。然而，一些旧版本浏览器会带来麻烦，需要一些特别的指令来纠正它。 如果你不能改你的.htaccess 文件，你可以用PHP来返回压缩的内容，给你的HTML文件一个.php 文件，把下边文件加在文件的最上边。IN PHP :1&lt;?php if (substr_count($_SERVER[‘HTTP_ACCEPT_ENCODING’], ‘gzip’)) ob_start(“ob_gzhandler”); else ob_start(); ?&gt; 我们会检查“Accept-encoding”头，返回gzip压缩版本的文件（不然就返回源文件）。这简直像是在建设你自己的web服务器。如果你确实在搭建服务器，请用Apache来压缩你的文件。你肯定不想下载你的文件 just like bearing。 这有点给apache打广告的意思啊 验证压缩的效果一旦你配置好了你的服务器，检查他是不是生效了。 在线查看：用online gzip test来检查你的网页是不是确实压缩了。 浏览器查看：在chrome谷歌浏览器，F12打开 开发者工具–&gt; network页签（火狐和IE浏览器也是相似的）。刷新你的页面，点击这network航信息来查看。这“Content-encoding: gzip” 的头信息意味着内容压缩了传过来的。 点击“use large rows”表情来查看更多信息。包含了压缩以后的大小和源文件的大小。 奇迹般的，主页从187kb压缩到了59kb。 试试几个小栗子我做了个几个页和一个下载demo： index.html —— 默认压缩 index.htm —— 通过在Apache上的.htaccess文件 增加 *.htm规则来压缩 index.php —— 通过php的头信息来压缩 随意下载这些文件，放到你的服务器，调整你的服务器设置。 警告gzip压缩的出现如此的令人振奋，但是还有以下三个注意点： 低版本浏览器：一些浏览器接受压缩文件还是有问题（他们说他们可以但是他们并不行），如果你的站点必须在window95的网景1.0浏览器上，你可能不想要压缩文件。Apache mod_deflate设置了一些忽略规则来专门为旧浏览器。 已经压缩过的文件:大多数的图片，音乐和视频都已经压缩过了，不要浪费时间来压缩他们了。事实上，你可以只压缩那三巨头（HTML,CSS AND JAVARSCRIPT)。 CPU负载：在传输过程中压缩文件耗费CPU但是节省带宽（用空间换时间）。通常压缩速率的选择需要权衡利弊。也存在一些预压缩静态文件的方法，但这要求更多的资源。考虑了cpu的耗费，压缩文件也是利大于弊。通过压缩实现更好的用户体验，更短的留白时间，值！ 开启gzip压缩是优化网站最快的方法之一。大胆的用吧，让你的用户体验更棒。 本文为翻译文章，欲了解原文请点击原文链接","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"guguji5.github.io/tags/优化/"}]},{"title":"Hexo + Github搭建静态博客(一)","slug":"Hexo-Github搭建静态博客-一","date":"2018-11-09T05:19:48.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"Hexo-Github搭建静态博客-一/","link":"","permalink":"guguji5.github.io/Hexo-Github搭建静态博客-一/","excerpt":"","text":"快速介绍Hexo是一个基于Node.js搭建的静态博客框架，通过Hexo，用户可以\b以博文的方式发布\bMarkdown文档。\b\b结合默认或定制化\b主题模板（很像其他静态博客生成框架，Jekyll或Ghost）博文会被转化和生成为HTML/CSS。Hexo所需的所有组件都是模块化的，\b所以你可以按需安装。 提前准备\b跟着本博客，你可能需要提前准备： git Node.js Github账号 第一步 安装和初始化Hexo这一步需要安装好Hexo所需的东西，Hexo是有许多软件包组成的，而最必要的一个就是npm，Node.js包管理器。 首先，安装hexo-cli,最重要最核心的Hexo命令。1$ npm install hexo-cli -g 其次，我们需要创建一些\b基础文件，很幸运，Hexo为我们提供了一键生成的命令。我们只需要\b切换到准备好的文件夹目录，执行如下命令。1$ hexo init 此时，文件夹下可能会出现很多文件和文件夹，如下图所示：123456789blog/├── _config.yml├── node_modules├── package.json├── scaffolds├── source└── theme4 directory, 2 files 第二步 \b设置Hexo主要的配置文件 _config.yml上图的这些文件中，_config.yml是至关重要的，所有的核心配置都存储在这个博客中，如果将来你想调整博客的一些设置，\b\b大概率就是这个文件。 我们将会一步一步的\b\b修改配置，选择你喜欢的编辑器，vi， nano 或者sublime等打开_config.yml，在最上边你会看到如下的内容。1234567# Sitetitle: Hexosubtitle:description:author: John Doelanguage:timezone: 前四行分别是博客的名称，\b二级名称，描述和作者的名称。目前不是所有的Hexo主题都会显示这些信息，所以它大多数当成网站\b基本信息。 后边两行是语言和时区，语言选择两字符ISO 639-1代码。时区默认指的是用户服务器的时区，用“tz database”格式。你可以根据需要修改他们，下边是一个例子：1234567#Sitetitle: 滴滴云博客 subtitle: 为开发者而生 description: 滴滴云基于滴滴出行的业务技术和经验积累,采用领先的云计算架构、高规格服务器集群搭建、高性能资源配置机制、精细化运营模式,致力于为开发者提供简单快捷、高效稳定。author: \bdidicloud language: zh-CN timezone: 主题 的更换是在_config.yml中theme字段。 最后我们要更改的设置是default_layout:\b 在Writing\b下边，在一个博文没发表之前，它是\b不可见的，我们想存成草稿，所以我们把default_layout\b设置成draft。1234# Writingnew_post_name: :title.md # File name of new postsdefault_layout: drafttitlecase: false # Transform title into titlecase 第三步 \b创建和发表博客用如下命令来创建一个博文（草稿）,这里的‘first-page’是博文的名称。 1$ hexo new first-post 然后我们应该会看到这样的显示：12OutputINFO Created: ~/hexo_blog/source/_drafts/first-post.md 我们可以选择自己喜欢的编辑器，打开first-post.md 每一个博文都有一个\bfront-matter设置，Front-matter是一个\bJSON or YAML块，它可以用来设置这标题，发布时间，标签等等。Front-matter\b\b一般用---或者;;;标志结尾。在Front-matter之后，你可以用Markdown语法写自己的博文。 用如下的内容替换\bfirst-post.md的内容。12345678910111213title: 滴滴云--为开发者而生tags: - Test - Blogcategories: - Hexocomments: truedate: 2018-11-04 00:00:00---## Markdown goes here.**This is our first post!** 然后执行$ hexo publish first-post会看到如下的结果：12OutputINFO Published: ~/hexo_blog/source/_posts/first-post.md 第四步 启动服务器\b到目前为止，所有的配置文件和博文都已准备完毕，接下来，我们启动服务器。1$ hexo server 现在，我们可以访问自己的博客通过http://localhost:4000。你会看到自己预设的hello-world博客,\bctrl+c可以停止服务器。 第五步 设置部署脚本到目前为止，Hexo有许多不同的方法可以部署，本博客是用git来进行存储，上传，托管博客。除此之外，还支持Heroku, Git, Rsync, OpenShift, FTPSync等多种工具。 这里需要一个git仓库来存储Hexo生成的静态HTML文件，为了简单起见，这里我们用Github提供的git仓库。 在Github上创建一个&lt;username&gt;.Github.io的仓库，选择“\bPublic”，并且点击“Initialize this repository with a README”\b选择框。然后打开_config.yml。1234# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 按如下所示，填上\bdeploy选项，你必须\b\b替换username为自己的Github账号。12345deploy: type: git repo: https://Github.com/username/username.Github.io.git //e.g. https://Github.com/guguji5/guguji5.Github.io.git branch: master \b因为我们选择了git来部署，所以我们需要安装Hexo包来发布静态模板到git仓库。用npm来安装：1$ npm install hexo-deployer-git --save 现在你可以部署你的代码到Github仓库了。1$ hexo generate &amp;&amp; hexo deploy 在Github密码校验框输入密码以后，如下是成功结果。1234567891011121314151617181920212223hexo HEXO GINFO Start processingINFO Files loaded in 214 msINFO Generated: archives/2018/index.htmlINFO Generated: repository/index.htmlINFO Generated: archives/index.htmlINFO Generated: about/index.htmlINFO Generated: archives/2018/11/index.htmlINFO Generated: index.htmlINFO Generated: angular-splitter/index.htmlINFO Generated: 如何使用GZIP来优化你的网站/index.htmlINFO 8 files generated in 231 ms➜ hexo HEXO DINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master 143ec29] Site updated: 2018-11-04 23:14:03 8 files changed, 80 deletions(-)To https://Github.com/guguji5/guguji5.Github.io.git c8f0b04..143ec29 HEAD -&gt; masterBranch master set up to track remote branch master from https://Github.com/guguji5/guguji5.Github.io.git.INFO Deploy done: git 结语完成了所有配置，\b快去搭建属于自己的静态博客吧。 https://guguji5.Github.io/ https://kouss.com/ Hexo\b的子页面包括归档、分类，标签使用，github项目的关联，ejs模板的配置将在下一篇《Hexo + Github搭建静态博客(二)》中给大家分享。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"guguji5.github.io/tags/Hexo/"}]},{"title":"angular-splitter","slug":"angular-splitter","date":"2018-11-09T04:15:55.000Z","updated":"2021-07-25T07:53:39.000Z","comments":true,"path":"angular-splitter/","link":"","permalink":"guguji5.github.io/angular-splitter/","excerpt":"","text":"this is a angular splitter that could drag the responsive layout, and also act like the layout of notes on mac. Onlinehttps://guguji5.github.io/angular-splitter-demo How to run1234git clone https://github.com/guguji5/angular-splitter.gitcd angular-splitternpm installng serve --open of course you must have angular-cli installed. Angular Supportangular 5~6 DocumentComponent &lt;tam-splitter&gt; @Input Type Default Details direction string “horizontal” Select split direction: “horizontal” or “vertical”. splitterBarWidth number 8 Gutters’s size (dragging elements) in pixels. useTransition boolean or number false Use transition when collapsing or expanding. when this param is a number, it will be a millisecond value set to the property ‘transition-duration’, should be between 100 and 1000 type string ‘standard’ it has two value(standard, macNotes), which controls the behavior of the drag, macNotes type will act like the notes on mac @Output Param Details sizeChange {barNum: number, sizes: Array&lt;number&gt;} Emit when draging, return the index of bar and the sizes of panels Component &lt;tam-splitter-panel&gt; @Input Type Default Details size number null Size of the panel in percent (value between 0 and 100).all panels sizes should be equal to 100 max number null Max size of the panel in percent (value between 0 and 100). min number null Min size of the panel in percent (value between 0 and 100). visible boolean true Allow to toggle panel visibility @Output Param Details collapsedChange {collapsed:boolean, sizes: Array&lt;number&gt;, collapsedComponentSize: number} Emit when collapsed or expand, return the collapsed, the sizes of panels and the size of collapsed panel simple demo:123456789101112&lt;tam-splitter splitterBarWidth=3 [direction]=&quot;horizontal&quot; (sizeChange)=&quot;sizeChange($event)&quot;&gt; &lt;tam-splitter-panel [size]=&quot;20&quot; [max]=&quot;30&quot; [min]=&quot;10&quot; [visible]=true (collapsedChange)=&quot;collapsedChange($event)&quot;&gt; Refined By Panel &lt;/tam-splitter-panel&gt; &lt;tam-splitter-panel [size]=&quot;30&quot; [max]=&quot;50&quot; [min]=&quot;20&quot;&gt; Side List Panel &lt;/tam-splitter-panel&gt; &lt;tam-splitter-panel [size]=&quot;50&quot; [max]=&quot;70&quot; [min]=&quot;20&quot;&gt; Preview Panel &lt;/tam-splitter-panel&gt;&lt;/tam-splitter&gt; nested demo:12345678910111213141516&lt;tam-splitter splitterBarWidth=3&gt; &lt;tam-splitter-panel [size]=&quot;20&quot; [max]=&quot;30&quot; [min]=&quot;10&quot; (collapsedChange)=&quot;collapsedChange($event)&quot;&gt; Refined By Panel &lt;/tam-splitter-panel&gt; &lt;tam-splitter-panel [size]=&quot;80&quot;&gt; &lt;tam-splitter splitterBarWidth=3 [direction]=&quot;&apos;vertical&apos;&quot;&gt; &lt;tam-splitter-panel [size]=&quot;30&quot; [max]=&quot;40&quot; [min]=&quot;20&quot;&gt; Side List Panel &lt;/tam-splitter-panel&gt; &lt;tam-splitter-panel [size]=&quot;70&quot; [max]=&quot;80&quot; [min]=&quot;60&quot;&gt; Preview Panel &lt;/tam-splitter-panel&gt; &lt;/tam-splitter&gt; &lt;/tam-splitter-panel&gt;&lt;/tam-splitter&gt; 中文README","categories":[{"name":"组件","slug":"组件","permalink":"guguji5.github.io/categories/组件/"}],"tags":[{"name":"angular","slug":"angular","permalink":"guguji5.github.io/tags/angular/"},{"name":"component","slug":"component","permalink":"guguji5.github.io/tags/component/"}]}]}